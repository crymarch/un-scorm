<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Expires" content="0">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" type="image/x-icon" href="https://cdn.worldvectorlogo.com/logos/red-hat-1.svg">
    <title>Un-SCORM</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            line-height: 1.6;
            color: #333;
            background: #f3f4f6;
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 800px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            overflow: hidden;
        }
        
        .header {
            background: #a60000;
            color: white;
            padding: 30px;
            text-align: center;
        }
        
        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            font-weight: 600;
        }
        
        .header p {
            font-size: 1.1em;
            opacity: 0.9;
        }
        
        .content {
            padding: 40px;
        }
        
        .upload-area {
            border: 3px dashed #ddd;
            border-radius: 10px;
            padding: 40px;
            text-align: center;
            margin-bottom: 30px;
            transition: all 0.3s ease;
            cursor: pointer;
        }
        
        .upload-area:hover, .upload-area.dragover {
            border-color: #4CAF50;
            background-color: #f9f9f9;
        }
        
        .upload-area.processing {
            border-color: #2196F3;
            background-color: #e3f2fd;
        }
        
        .upload-icon {
            font-size: 3em;
            color: #ddd;
            margin-bottom: 20px;
        }
        
        .upload-area:hover .upload-icon {
            color: #4CAF50;
        }
        
        .upload-text {
            font-size: 1.2em;
            color: #666;
            margin-bottom: 10px;
        }
        
        .upload-subtext {
            color: #999;
            font-size: 0.9em;
        }
        
        .file-input {
            display: none;
        }
        
        .status {
            margin-top: 20px;
            padding: 15px;
            border-radius: 8px;
            display: none;
        }
        
        .status.success {
            background-color: #d4edda;
            border: 1px solid #c3e6cb;
            color: #155724;
        }
        
        .status.error {
            background-color: #f8d7da;
            border: 1px solid #f5c6cb;
            color: #721c24;
        }
        
        .status.processing {
            background-color: #cce7ff;
            border: 1px solid #99d5ff;
            color: #0066cc;
        }
        
        .progress-bar {
            width: 100%;
            height: 6px;
            background-color: #f0f0f0;
            border-radius: 3px;
            margin-top: 10px;
            overflow: hidden;
        }
        
        .progress-fill {
            height: 100%;
            background: #a60000;
            width: 0%;
            transition: width 0.3s ease;
        }
        
        .download-btn {
            background: #a60000;
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 8px;
            font-size: 1.1em;
            cursor: pointer;
            margin-top: 15px;
            transition: all 0.3s ease;
            display: none;
        }
        
        .download-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(166, 0, 0, 0.3);
        }
        
        .supported-formats {
            background-color: #f8f9fa;
            border-radius: 8px;
            padding: 20px;
            margin-top: 30px;
        }
        
        .supported-formats h3 {
            color: #495057;
            margin-bottom: 15px;
        }
        
        .format-list {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
        }
        
        .format-item {
            background: white;
            padding: 15px;
            border-radius: 6px;
            border-left: 4px solid #4CAF50;
        }

        .format-item.limited {
            border-left-color: #ffa500;
        }

        .format-item.metadata-only {
            border-left-color: #ff6b35;
        }
        
        .format-title {
            font-weight: 600;
            color: #333;
            margin-bottom: 5px;
        }
        
        .format-desc {
            color: #666;
            font-size: 0.9em;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <div style="display: flex; align-items: center; justify-content: center; gap: 15px; margin-bottom: 10px;">
                <h1 style="margin: 0;">ü™Ñ Un-SCORM</h1>
            </div>
            <p>Convert SCORM packages to clean, reviewable markdown files</p>
        </div>
        
        <div class="content">
            <div class="upload-area" id="uploadArea">
                <div class="upload-icon">üìÅ</div>
                <div class="upload-text">Drop your SCORM zip file here</div>
                <div class="upload-subtext">or click to browse</div>
                <input type="file" class="file-input" id="fileInput" accept=".zip">
            </div>
            
            <div class="status" id="status">
                <div id="statusText"></div>
                <div class="progress-bar">
                    <div class="progress-fill" id="progressFill"></div>
                </div>
            </div>
            
            <div class="output-options" id="outputOptions" style="display: none; margin: 20px 0;">
                <h3>üìÑ Output Format</h3>
                <div style="display: flex; gap: 15px; align-items: center; flex-wrap: wrap;">
                    <label style="display: flex; align-items: center; gap: 5px;">
                        <input type="radio" name="outputFormat" value="markdown" checked>
                        <span>üìù Markdown (.md) - Text format with full metadata</span>
                    </label>
                    <label style="display: flex; align-items: center; gap: 5px;">
                        <input type="radio" name="outputFormat" value="html">
                        <span>üåê HTML (.html) - Formatted web page with styling</span>
                    </label>
                </div>
                <div style="margin-top: 10px; font-size: 0.9em; color: #666;">
                    Both formats include complete content metadata, media information, and interactive element details.
                </div>
            </div>
            
            <button class="download-btn" id="downloadBtn">üì• Download Content</button>
            
            <div class="supported-formats">
                <h3>üîß Supported Formats</h3>
                <div class="format-list">
                    <div class="format-item">
                        <div class="format-title">SCORM 1.2 - Articulate Rise</div>
                        <div class="format-desc">Full content extraction: text, quizzes (some limitations), interactions, flashcards, scenarios, media metadata</div>
                    </div>
                    <div class="format-item limited">
                        <div class="format-title">SCORM 1.2 - Storyline <span style="color: #ffa500; font-weight: bold; font-size: 0.8em;">(LIMITED)</span></div>
                        <div class="format-desc">Basic content extraction: course title, metadata, PDF resources, limited HTML text</div>
                    </div>
                    <div class="format-item metadata-only">
                        <div class="format-title">SCORM 1.2 - Flash/Captivate <span style="color: #ff6b35; font-weight: bold; font-size: 0.8em;">(METADATA ONLY)</span></div>
                        <div class="format-desc">Technical analysis: file inventory, interaction types, configuration, no content text</div>
                    </div>
                    <div class="format-item">
                        <div class="format-title">SCORM 2004 - GitBook Style</div>
                        <div class="format-desc">Full content extraction: structured text from HTML pages, navigation, complete course content</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Footer with links -->
    <footer style="margin-top: 40px; padding: 20px; background: #f8f9fa; border-top: 1px solid #dee2e6; text-align: center; font-size: 14px; color: #6c757d;">
        <div style="max-width: 800px; margin: 0 auto;">
            <p style="margin: 0 0 15px 0; font-weight: 600; color: #495057;">üìö Need Help or Have Feedback?</p>
            <div style="display: flex; justify-content: center; gap: 30px; flex-wrap: wrap;">
                <a href="https://docs.google.com/document/d/1GHh8QSlrmzEcP7FeomaZsmL7F0db6VGD1zR2knNg6v0/edit?tab=t.0" 
                   target="_blank" 
                   style="color: #007bff; text-decoration: none; display: flex; align-items: center; gap: 5px;">
                    üìñ User Guide
                </a>
                <a href="https://docs.google.com/document/d/1GHh8QSlrmzEcP7FeomaZsmL7F0db6VGD1zR2knNg6v0/edit?tab=t.670ks06i8gue" 
                   target="_blank" 
                   style="color: #dc3545; text-decoration: none; display: flex; align-items: center; gap: 5px;">
                    üêõ Report Bug
                </a>
                <a href="https://docs.google.com/document/d/1GHh8QSlrmzEcP7FeomaZsmL7F0db6VGD1zR2knNg6v0/edit?tab=t.frgq9faptgfo" 
                   target="_blank" 
                   style="color: #28a745; text-decoration: none; display: flex; align-items: center; gap: 5px;">
                    üí° Feature Request
                </a>
            </div>
            <div style="display: flex; align-items: center; justify-content: center; gap: 8px; margin: 15px 0 0 0; font-size: 12px;">
                <span>Un-SCORM ‚Äî SCORM extraction made simple (est. 2025)</span>
            </div>
        </div>
    </footer>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script>
        class ScormExtractor {
            constructor() {
                this.setupEventListeners();
                this.extractedContent = null;
                this.filename = null;
            }
            
            setupEventListeners() {
                const uploadArea = document.getElementById('uploadArea');
                const fileInput = document.getElementById('fileInput');
                const downloadBtn = document.getElementById('downloadBtn');
                
                uploadArea.addEventListener('click', () => fileInput.click());
                uploadArea.addEventListener('dragover', this.handleDragOver.bind(this));
                uploadArea.addEventListener('drop', this.handleDrop.bind(this));
                uploadArea.addEventListener('dragenter', this.handleDragEnter.bind(this));
                uploadArea.addEventListener('dragleave', this.handleDragLeave.bind(this));
                
                fileInput.addEventListener('change', this.handleFileSelect.bind(this));
                downloadBtn.addEventListener('click', this.downloadFile.bind(this));
                
                // Add drag and drop to the entire body for better capture
                document.body.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    console.log('Drag over body detected');
                });
                
                document.body.addEventListener('drop', ((e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    console.log('Drop on body detected');
                    
                    const files = e.dataTransfer.files;
                    if (files.length > 0) {
                        console.log('File dropped:', files[0].name);
                        if (files[0].name.toLowerCase().endsWith('.zip')) {
                            this.processFile(files[0]);
                        } else {
                            this.showStatus('error', 'Please drop a ZIP file.');
                        }
                    }
                }).bind(this));
                
                // Also prevent default on document level as backup
                document.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                });
                
                document.addEventListener('drop', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                });
            }
            
            handleDragOver(e) {
                e.preventDefault();
                e.stopPropagation();
                document.getElementById('uploadArea').classList.add('dragover');
            }
            
            handleDragEnter(e) {
                e.preventDefault();
                e.stopPropagation();
                document.getElementById('uploadArea').classList.add('dragover');
            }
            
            handleDragLeave(e) {
                e.preventDefault();
                e.stopPropagation();
                // Only remove dragover if we're leaving the upload area completely
                if (!e.currentTarget.contains(e.relatedTarget)) {
                    document.getElementById('uploadArea').classList.remove('dragover');
                }
            }
            
            handleDrop(e) {
                e.preventDefault();
                e.stopPropagation();
                console.log('Drop on upload area detected');
                document.getElementById('uploadArea').classList.remove('dragover');
                const files = e.dataTransfer.files;
                if (files.length > 0) {
                    console.log('Processing file from upload area:', files[0].name);
                    this.processFile(files[0]);
                } else {
                    console.log('No files in drop event');
                }
            }
            
            handleFileSelect(e) {
                const file = e.target.files[0];
                if (file) {
                    this.processFile(file);
                }
            }
            
            async processFile(file) {
                if (!file.name.toLowerCase().endsWith('.zip')) {
                    this.showStatus('error', 'Please select a ZIP file.');
                    return;
                }
                
                this.filename = file.name.replace('.zip', '');
                this.showStatus('processing', 'Processing SCORM package...');
                this.updateProgress(10);
                
                let zip = null;
                try {
                    zip = await JSZip.loadAsync(file);
                    this.updateProgress(30);
                    
                    // Detect SCORM type
                    const scormType = await this.detectScormType(zip);
                    this.updateProgress(40);
                    
                    let extractedContent;
                                    if (scormType === 'scorm12_rise_ultra') {
                    extractedContent = await this.extractScorm12RiseUltra(zip);
                } else if (scormType === 'scorm12_rise') {
                    extractedContent = await this.extractScorm12Rise(zip);
                } else if (scormType === 'scorm12_storyline') {
                    extractedContent = await this.extractScorm12Storyline(zip);
                } else if (scormType === 'scorm12_flash') {
                    extractedContent = await this.extractScorm12Flash(zip);
                } else if (scormType === 'scorm2004') {
                    extractedContent = await this.extractScorm2004(zip);
                } else {
                    throw new Error('Unsupported SCORM format or structure');
                }
                    
                    this.updateProgress(90);
                    this.extractedContent = extractedContent;
                    this.updateProgress(100);
                    
                    this.showStatus('success', `Successfully extracted content! Found ${extractedContent.split('\n').length} lines of content.`);
                    
                    // Check if there's a notice about quiz issues
                    const hasNotice = extractedContent.includes('NOTICE: This quiz may have answer key issues');
                    
                    if (hasNotice) {
                        this.showStatus('warning', '‚ö†Ô∏è Quiz validation detected potential issues. Please review the extracted content carefully.');
                    }
                    
                    document.getElementById('downloadBtn').style.display = 'block';
                    document.getElementById('outputOptions').style.display = 'block';
                    
                } catch (error) {
                    console.error('Processing error:', error);
                    
                    // Try alternative extraction methods if primary method fails
                    if (zip) {
                        console.log('üîÑ Primary extraction failed, trying alternative methods...');
                        try {
                            const alternativeContent = await this.tryAlternativeExtractionMethods(zip);
                            if (alternativeContent) {
                                this.updateProgress(100);
                                this.extractedContent = alternativeContent;
                                this.showStatus('success', `‚úÖ Successfully extracted content using alternative methods! Found ${alternativeContent.split('\n').length} lines of content.`);
                                document.getElementById('downloadBtn').style.display = 'block';
                                document.getElementById('outputOptions').style.display = 'block';
                            } else {
                                this.showStatus('error', `Error processing file: ${error.message}`);
                            }
                        } catch (altError) {
                            console.error('Alternative extraction also failed:', altError);
                            this.showStatus('error', `Error processing file: ${error.message}. Alternative methods also failed: ${altError.message}`);
                        }
                    } else {
                        // If zip couldn't be loaded, try loading it again for alternative methods
                        console.log('üîÑ Primary extraction failed, trying to reload ZIP for alternative methods...');
                        try {
                            zip = await JSZip.loadAsync(file);
                            const alternativeContent = await this.tryAlternativeExtractionMethods(zip);
                            if (alternativeContent) {
                                this.updateProgress(100);
                                this.extractedContent = alternativeContent;
                                this.showStatus('success', `‚úÖ Successfully extracted content using alternative methods! Found ${alternativeContent.split('\n').length} lines of content.`);
                                document.getElementById('downloadBtn').style.display = 'block';
                                document.getElementById('outputOptions').style.display = 'block';
                            } else {
                                this.showStatus('error', `Error processing file: ${error.message}`);
                            }
                        } catch (altError) {
                            console.error('Alternative extraction also failed:', altError);
                            this.showStatus('error', `Error processing file: ${error.message}. Alternative methods also failed: ${altError.message}`);
                        }
                    }
                }
            }
            
            // Alternative extraction methods when primary parsing fails
            async tryAlternativeExtractionMethods(zip) {
                const results = [];
                
                results.push('# Alternative Quiz Extraction Methods');
                results.push('*Primary extraction failed - trying alternative approaches...*\n');
                
                // Method 1: Raw JavaScript File Analysis
                const jsResults = await this.extractFromJavaScriptFiles(zip);
                if (jsResults.length > 0) {
                    results.push('## üìÑ Method 1: JavaScript File Analysis');
                    results.push(...jsResults);
                    results.push('');
                }
                
                // Method 2: HTML Content Scraping
                const htmlResults = await this.extractFromHtmlFiles(zip);
                if (htmlResults.length > 0) {
                    results.push('## üåê Method 2: HTML Content Scraping');
                    results.push(...htmlResults);
                    results.push('');
                }
                
                // Method 3: XML Manifest Parsing
                const xmlResults = await this.extractFromXmlFiles(zip);
                if (xmlResults.length > 0) {
                    results.push('## üìã Method 3: XML Manifest Analysis');
                    results.push(...xmlResults);
                    results.push('');
                }
                
                // Method 4: Binary/Encoded Data Analysis
                const binaryResults = await this.extractFromBinaryData(zip);
                if (binaryResults.length > 0) {
                    results.push('## üîç Method 4: Binary/Encoded Data Analysis');
                    results.push(...binaryResults);
                    results.push('');
                }
                
                // Method 5: Pattern-Based Text Extraction
                const patternResults = await this.extractUsingPatterns(zip);
                if (patternResults.length > 0) {
                    results.push('## üéØ Method 5: Pattern-Based Extraction');
                    results.push(...patternResults);
                    results.push('');
                }
                
                if (results.length > 3) { // More than just headers
                    return results.join('\n');
                }
                
                return null;
            }
            
            // Extract quiz data from JavaScript files
            async extractFromJavaScriptFiles(zip) {
                const results = [];
                
                for (const filePath in zip.files) {
                    const file = zip.files[filePath];
                    if (file.name.endsWith('.js') && !file.dir) {
                        try {
                            const content = await file.async('string');
                            
                            // Look for base64 encoded data (like in und.js)
                            const base64Match = content.match(/__resolveJsonp\([^,]+,\s*"([^"]+)"/);
                            if (base64Match) {
                                try {
                                    const decoded = atob(base64Match[1]);
                                    const jsonData = JSON.parse(decoded);
                                    
                                    if (jsonData.course && jsonData.course.lessons) {
                                        results.push(`### Found encoded course data in: ${file.name}`);
                                        results.push(`**Course Title:** ${jsonData.course.title || 'Untitled'}`);
                                        results.push(`**Lessons Found:** ${jsonData.course.lessons.length}`);
                                        
                                        // Extract quiz questions
                                        jsonData.course.lessons.forEach((lesson, index) => {
                                            if (lesson.items) {
                                                const questions = lesson.items.filter(item => 
                                                    item.answers && Array.isArray(item.answers)
                                                );
                                                
                                                if (questions.length > 0) {
                                                    results.push(`\n**Lesson ${index + 1}: ${lesson.title || 'Untitled'}**`);
                                                    
                                                    questions.forEach((question, qIndex) => {
                                                        results.push(`\n#### Question ${qIndex + 1}`);
                                                        results.push(question.title || 'Untitled Question');
                                                        results.push('**Type:** Multiple Choice\n');
                                                        results.push('**Answer Options:**');
                                                        
                                                        question.answers.forEach((answer, aIndex) => {
                                                            const letter = String.fromCharCode(65 + aIndex);
                                                            const isCorrect = answer.correct ? ' ‚úÖ' : '';
                                                            const text = answer.title || answer.html || answer.text || '';
                                                            results.push(`${letter}. ${text}${isCorrect}`);
                                                        });
                                                    });
                                                }
                                            }
                                        });
                                    }
                                } catch (decodeError) {
                                    console.warn('Failed to decode base64 data:', decodeError);
                                }
                            }
                            
                            // Look for quiz-related patterns in JavaScript
                            const quizPatterns = [
                                /questions?\s*[:=]\s*\[/gi,
                                /answers?\s*[:=]\s*\[/gi,
                                /correct\s*[:=]\s*["']?[^"',]+["']?/gi
                            ];
                            
                            quizPatterns.forEach(pattern => {
                                const matches = content.match(pattern);
                                if (matches) {
                                    results.push(`### Quiz patterns found in: ${file.name}`);
                                    matches.forEach(match => {
                                        results.push(`- ${match.substring(0, 100)}...`);
                                    });
                                }
                            });
                            
                        } catch (error) {
                            console.warn(`Error processing JS file ${file.name}:`, error);
                        }
                    }
                }
                
                return results;
            }
            
            // Extract quiz data from HTML files
            async extractFromHtmlFiles(zip) {
                const results = [];
                
                for (const filePath in zip.files) {
                    const file = zip.files[filePath];
                    if (file.name.endsWith('.html') && !file.dir) {
                        try {
                            const content = await file.async('string');
                            const parser = new DOMParser();
                            const doc = parser.parseFromString(content, 'text/html');
                            
                            // Look for quiz-related elements
                            const quizElements = [
                                'input[type="radio"]',
                                'input[type="checkbox"]',
                                '.question',
                                '.quiz',
                                '[data-question]',
                                '[data-answer]'
                            ];
                            
                            let foundQuizContent = false;
                            
                            quizElements.forEach(selector => {
                                const elements = doc.querySelectorAll(selector);
                                if (elements.length > 0) {
                                    if (!foundQuizContent) {
                                        results.push(`### Quiz elements found in: ${file.name}`);
                                        foundQuizContent = true;
                                    }
                                    
                                    results.push(`**${selector}:** ${elements.length} elements found`);
                                    
                                    // Try to extract question text
                                    elements.forEach((element, index) => {
                                        if (index < 5) { // Limit to first 5 for readability
                                            const text = element.textContent?.trim();
                                            if (text && text.length > 10) {
                                                results.push(`  - ${text.substring(0, 150)}...`);
                                            }
                                        }
                                    });
                                }
                            });
                            
                            // Look for embedded JSON data
                            const scriptTags = doc.querySelectorAll('script');
                            scriptTags.forEach(script => {
                                const scriptContent = script.textContent || '';
                                if (scriptContent.includes('question') || scriptContent.includes('answer')) {
                                    results.push(`### Script with quiz data found in: ${file.name}`);
                                    const snippet = scriptContent.substring(0, 300).replace(/\s+/g, ' ');
                                    results.push(`\`\`\`javascript\n${snippet}...\n\`\`\``);
                                }
                            });
                            
                        } catch (error) {
                            console.warn(`Error processing HTML file ${file.name}:`, error);
                        }
                    }
                }
                
                return results;
            }
            
            // Extract quiz data from XML files
            async extractFromXmlFiles(zip) {
                const results = [];
                
                for (const filePath in zip.files) {
                    const file = zip.files[filePath];
                    if (file.name.endsWith('.xml') && !file.dir) {
                        try {
                            const content = await file.async('string');
                            
                            // Look for quiz-related XML elements
                            const quizKeywords = ['question', 'answer', 'quiz', 'assessment', 'interaction'];
                            let foundQuizXml = false;
                            
                            quizKeywords.forEach(keyword => {
                                const regex = new RegExp(`<[^>]*${keyword}[^>]*>`, 'gi');
                                const matches = content.match(regex);
                                if (matches) {
                                    if (!foundQuizXml) {
                                        results.push(`### Quiz XML elements found in: ${file.name}`);
                                        foundQuizXml = true;
                                    }
                                    results.push(`**${keyword} elements:** ${matches.length} found`);
                                    matches.slice(0, 3).forEach(match => {
                                        results.push(`  - ${match}`);
                                    });
                                }
                            });
                            
                            // Try to parse as XML and look for structured data
                            try {
                                const parser = new DOMParser();
                                const xmlDoc = parser.parseFromString(content, 'text/xml');
                                
                                // Look for common SCORM quiz elements
                                const commonElements = ['item', 'resource', 'title', 'description'];
                                commonElements.forEach(elementName => {
                                    const elements = xmlDoc.getElementsByTagName(elementName);
                                    if (elements.length > 0) {
                                        results.push(`**${elementName} elements:** ${elements.length} found in ${file.name}`);
                                        for (let i = 0; i < Math.min(3, elements.length); i++) {
                                            const text = elements[i].textContent?.trim();
                                            if (text) {
                                                results.push(`  - ${text.substring(0, 100)}...`);
                                            }
                                        }
                                    }
                                });
                            } catch (xmlError) {
                                console.warn(`XML parsing failed for ${file.name}:`, xmlError);
                            }
                            
                        } catch (error) {
                            console.warn(`Error processing XML file ${file.name}:`, error);
                        }
                    }
                }
                
                return results;
            }
            
            // Extract from binary/encoded data
            async extractFromBinaryData(zip) {
                const results = [];
                
                for (const filePath in zip.files) {
                    const file = zip.files[filePath];
                    if (!file.dir) {
                        try {
                            // Try reading as text first
                            const content = await file.async('string');
                            
                            // Look for base64 encoded content
                            const base64Patterns = [
                                /[A-Za-z0-9+\/]{100,}={0,2}/g, // Base64 patterns
                                /"data:.*?base64,([^"]+)"/g    // Data URLs
                            ];
                            
                            base64Patterns.forEach((pattern, patternIndex) => {
                                const matches = content.match(pattern);
                                if (matches) {
                                    results.push(`### Base64 data found in: ${file.name}`);
                                    matches.slice(0, 2).forEach((match, matchIndex) => {
                                        try {
                                            const base64Data = patternIndex === 1 ? match.split(',')[1] : match;
                                            const decoded = atob(base64Data);
                                            
                                            if (decoded.includes('question') || decoded.includes('answer')) {
                                                results.push(`**Encoded quiz data ${matchIndex + 1}:**`);
                                                results.push('```');
                                                results.push(decoded.substring(0, 500) + '...');
                                                results.push('```');
                                            }
                                        } catch (decodeError) {
                                            // Not valid base64, skip
                                        }
                                    });
                                }
                            });
                            
                        } catch (error) {
                            // File might be binary, try other approaches
                            console.warn(`Binary analysis failed for ${file.name}:`, error);
                        }
                    }
                }
                
                return results;
            }
            
            // Extract using text patterns
            async extractUsingPatterns(zip) {
                const results = [];
                
                // Common quiz text patterns to look for
                const quizPatterns = [
                    { name: 'Question Numbers', pattern: /(?:Question|Q)\s*\d+[:\.]?\s*([^\n\r]{20,200})/gi },
                    { name: 'Multiple Choice', pattern: /[A-D][\.\)]\s*([^\n\r]{10,150})/g },
                    { name: 'True/False', pattern: /(True|False)\s*[:\-]?\s*([^\n\r]{10,100})/gi },
                    { name: 'Answer Keys', pattern: /(?:Answer|Correct)[:\s]*([A-D]|True|False)/gi },
                    { name: 'Quiz Instructions', pattern: /(?:Choose|Select|Mark)\s+(?:the|all|one)[^\n\r]{10,100}/gi }
                ];
                
                for (const filePath in zip.files) {
                    const file = zip.files[filePath];
                    if (!file.dir) {
                        try {
                            const content = await file.async('string');
                            
                            quizPatterns.forEach(({ name, pattern }) => {
                                const matches = content.match(pattern);
                                if (matches && matches.length > 0) {
                                    results.push(`### ${name} found in: ${file.name}`);
                                    matches.slice(0, 5).forEach((match, index) => {
                                        results.push(`${index + 1}. ${match.trim()}`);
                                    });
                                    results.push('');
                                }
                            });
                            
                        } catch (error) {
                            console.warn(`Pattern extraction failed for ${file.name}:`, error);
                        }
                    }
                }
                
                return results;
            }
            
            async detectScormType(zip) {
                console.log('üîç Detecting SCORM type...');
                console.log('üìÅ Available files in ZIP:');
                
                const allFiles = Object.keys(zip.files).slice(0, 20); // Show first 20 files
                allFiles.forEach(file => console.log(`   ${file}`));
                if (Object.keys(zip.files).length > 20) {
                    console.log(`   ... and ${Object.keys(zip.files).length - 20} more files`);
                }
                
                // Check for SCORM 1.2 Articulate Rise structure
                const riseFiles = [];
                const riseLibFiles = [];
                
                for (const filePath in zip.files) {
                    if (filePath.startsWith('scormcontent/locales/') && filePath.endsWith('.js')) {
                        riseFiles.push(filePath);
                    }
                    if (filePath.startsWith('scormcontent/lib/rise/') && filePath.endsWith('.js')) {
                        riseLibFiles.push(filePath);
                    }
                }
                
                // Check for Ultra-Modern Rise (webpack-based with index.html and __fetchCourse)
                const hasIndexHtml = zip.files['scormcontent/index.html'];
                
                console.log('üîç Ultra-modern check:', {
                    hasIndexHtml: !!hasIndexHtml,
                    riseLibFilesCount: riseLibFiles.length,
                    riseLibFiles: riseLibFiles
                });
                
                if (hasIndexHtml && riseLibFiles.length > 0) {
                    // Check if index.html contains __fetchCourse function (ultra-modern indicator)
                    try {
                        const indexContent = await hasIndexHtml.async('text');
                        if (indexContent.includes('__fetchCourse()') && indexContent.includes('deserialize(')) {
                            console.log('‚úÖ Detected SCORM 1.2 Rise (Ultra-Modern) - found index.html + lib/rise files + __fetchCourse');
                            return 'scorm12_rise_ultra';
                        } else {
                            console.log('üìù Found index.html + lib/rise but no __fetchCourse - treating as Modern Rise');
                            // Fall through to check for other Rise patterns below
                        }
                    } catch (error) {
                        console.log('‚ö†Ô∏è Could not read index.html - treating as Modern Rise');
                        // Fall through to check for other Rise patterns below
                    }
                }
                
                // Debug: Show what Rise files were found
                console.log('üîç Rise detection results:', {
                    riseFiles: riseFiles.length,
                    riseLibFiles: riseLibFiles.length,
                    hasIndexHtml: !!hasIndexHtml
                });
                
                // Check for Classic Rise first (locales files)
                if (riseFiles.length > 0) {
                    console.log('‚úÖ Detected SCORM 1.2 Rise (Classic) - found locales files:', riseFiles);
                    return 'scorm12_rise';
                } else if (riseLibFiles.length > 0) {
                    console.log('‚úÖ Detected SCORM 1.2 Rise (Modern) - found lib/rise files:', riseLibFiles);
                    return 'scorm12_rise';
                }
                
                // Check for SCORM 1.2 Storyline structure
                if (zip.files['story.html'] && zip.files['imsmanifest.xml']) {
                    console.log('‚úÖ Detected SCORM 1.2 Storyline - found story.html and imsmanifest.xml');
                    return 'scorm12_storyline';
                }
                
                // Check for Flash-based SCORM (Adobe Captivate, etc.)
                if (zip.files['imsmanifest.xml']) {
                    // Look for .swf files and .htm files which indicate Flash-based content
                    const hasSwfFiles = Object.keys(zip.files).some(path => path.endsWith('.swf'));
                    const hasHtmFiles = Object.keys(zip.files).some(path => path.endsWith('.htm'));
                    
                    if (hasSwfFiles && hasHtmFiles) {
                        return 'scorm12_flash';
                    }
                }
                
                // Check for SCORM 2004 GitBook structure
                if (zip.files['scormcontent/search_index.json']) {
                    return 'scorm2004';
                }
                
                return null;
            }
            
            async extractScorm12RiseUltra(zip) {
                console.log('üöÄ Processing Ultra-Modern Rise SCORM...');
                
                // Store zip reference for PDF transcript extraction
                this.currentZip = zip;
                // Initialize transcript cache for this extraction
                this.transcriptCache = new Map();
                
                try {
                    // Extract and analyze index.html
                    const indexFile = zip.files['scormcontent/index.html'];
                    if (!indexFile) {
                        throw new Error('index.html not found in scormcontent/');
                    }
                    
                    const indexContent = await indexFile.async('text');
                    console.log('üìÑ Extracted index.html content');
                    
                    // Look for __fetchCourse() function with base64 data
                    const fetchCourseMatch = indexContent.match(/async function __fetchCourse\(\)\s*\{[\s\S]*?return Promise\.resolve\(deserialize\("([^"]+)"\)\)/);
                    
                    if (!fetchCourseMatch) {
                        console.log('‚ùå No __fetchCourse() function found in index.html');
                        throw new Error('__fetchCourse() function not found');
                    }
                    
                    const base64Data = fetchCourseMatch[1];
                    console.log('üîç Found base64 course data:', base64Data.substring(0, 100) + '...');
                    
                    // Deserialize the base64 data (same logic as in the HTML)
                    try {
                        const buffer = Uint8Array.from(atob(base64Data), c => c.charCodeAt(0));
                        const jsonString = new TextDecoder().decode(buffer);
                        const courseData = JSON.parse(jsonString);
                        
                        console.log('‚úÖ Successfully parsed course data');
                        console.log('üìä Course structure:', {
                            title: courseData.course?.title,
                            lessonsCount: courseData.course?.lessons?.length || 0,
                            hasQuizzes: courseData.course?.lessons?.some(lesson => 
                                lesson.blocks?.some(block => block.type === 'quiz' || block.type === 'knowledge-check')
                            ) || false
                        });
                        
                        // Debug: Log the actual structure (ULTRA-MODERN ONLY)
                        console.log('üîç Full course data keys:', Object.keys(courseData));
                        if (courseData.course) {
                            console.log('üîç Course object keys:', Object.keys(courseData.course));
                            if (courseData.course.lessons && Array.isArray(courseData.course.lessons) && courseData.course.lessons.length > 0) {
                                const firstLesson = courseData.course.lessons[0];
                                console.log('üîç First lesson keys:', Object.keys(firstLesson));
                                
                                // Check for items/blocks structure
                                if (firstLesson.items && Array.isArray(firstLesson.items)) {
                                    console.log('üîç First lesson items count:', firstLesson.items.length);
                                    if (firstLesson.items.length > 0) {
                                        const firstItem = firstLesson.items[0];
                                        console.log('üîç First lesson first item keys:', Object.keys(firstItem || {}));
                                        
                                        // Check for transcript data in media items
                                        if (firstItem && firstItem.media) {
                                            console.log('üîç First item media keys:', Object.keys(firstItem.media));
                                            if (firstItem.media.attachment) {
                                                console.log('üîç First item attachment:', firstItem.media.attachment);
                                            }
                                        }
                                    }
                                }
                                
                                if (firstLesson.blocks && Array.isArray(firstLesson.blocks)) {
                                    console.log('üîç First lesson blocks count:', firstLesson.blocks.length);
                                    if (firstLesson.blocks.length > 0) {
                                        console.log('üîç First lesson first block keys:', Object.keys(firstLesson.blocks[0] || {}));
                                    }
                                }
                            }
                        }
                        
                        // Ultra-modern Rise has course data nested under .course
                        // Restructure it to match what parseRiseContent expects
                        const riseFormat = {
                            title: courseData.course.title,
                            lessons: courseData.course.lessons,
                            ...courseData.course
                        };
                        
                        return await this.parseRiseContent(riseFormat);
                        
                    } catch (deserializeError) {
                        console.error('‚ùå Failed to deserialize base64 data:', deserializeError);
                        throw new Error('Failed to deserialize course data: ' + deserializeError.message);
                    }
                    
                } catch (error) {
                    console.error('‚ùå Ultra-Modern Rise extraction failed:', error);
                    throw error;
                }
            }
            
            async extractScorm12Rise(zip) {
                // Store zip reference for PDF transcript extraction
                this.currentZip = zip;
                // Initialize transcript cache for this extraction
                this.transcriptCache = new Map();
                
                console.log('üîç Starting Rise extraction...');
                
                // Find any .js file in the locales directory
                let localesFile = null;
                let languageCode = '';
                
                console.log('üìÅ Looking for Rise data files in ZIP...');
                const localesFiles = [];
                const riseLibFiles = [];
                
                for (const filePath in zip.files) {
                    if (filePath.startsWith('scormcontent/locales/') && filePath.endsWith('.js')) {
                        localesFiles.push(filePath);
                        if (!localesFile) {
                            localesFile = zip.files[filePath];
                            languageCode = filePath.split('/').pop().replace('.js', '');
                        }
                    } else if (filePath.startsWith('scormcontent/lib/rise/') && filePath.endsWith('.js')) {
                        riseLibFiles.push(filePath);
                    }
                }
                
                console.log(`üìÅ Found ${localesFiles.length} locales files:`, localesFiles);
                console.log(`üìÅ Found ${riseLibFiles.length} lib/rise files:`, riseLibFiles);
                
                // If no locales files, try to find data in lib/rise files
                if (!localesFile && riseLibFiles.length > 0) {
                    console.log('üîç No locales files found, searching lib/rise files for course data...');
                    
                    // Search through all lib/rise files for different patterns
                    for (const filePath of riseLibFiles) {
                        const file = zip.files[filePath];
                        const content = await file.async('text');
                        console.log(`üîç Checking ${filePath} (${content.length} chars)...`);
                        
                        // Look for various course data patterns
                        const hasResolveJsonp = content.includes('__resolveJsonp');
                        const hasWpRiseJsonp = content.includes('wpRiseJsonp');
                        const hasCourseObject = content.includes('"course"') && content.includes('"title"');
                        const hasLessons = content.includes('"lessons"') && content.includes('[');
                        const hasBase64Data = /"[A-Za-z0-9+/]{200,}={0,2}"/.test(content);
                        
                        console.log(`   - __resolveJsonp: ${hasResolveJsonp}`);
                        console.log(`   - wpRiseJsonp: ${hasWpRiseJsonp}`);
                        console.log(`   - course object: ${hasCourseObject}`);
                        console.log(`   - lessons array: ${hasLessons}`);
                        console.log(`   - base64 data: ${hasBase64Data}`);
                        
                        // Prioritize files with actual course structure
                        if (hasLessons || hasCourseObject || hasResolveJsonp || hasWpRiseJsonp || hasBase64Data) {
                            console.log(`üì¶ Found potential course data in: ${filePath}`);
                            localesFile = file;
                            languageCode = 'und'; // default language code
                            
                            // If we found lessons or course object, this is likely the main file
                            if (hasLessons || hasCourseObject) {
                                console.log(`‚úÖ High confidence course data found in: ${filePath}`);
                                break;
                            }
                        }
                    }
                }
                
                console.log(`üåê Using language code: ${languageCode}`);
                
                if (!localesFile) {
                    throw new Error('Could not find any Rise data files (locales or lib/rise)');
                }
                
                const jsContent = await localesFile.async('text');
                console.log(`üìÑ JS content length: ${jsContent.length} characters`);
                console.log(`üìÑ JS content preview:`, jsContent.substring(0, 200) + '...');
                this.updateProgress(50);
                
                // Extract the compressed data using multiple patterns
                console.log('üîç Searching for compressed data patterns...');
                
                // Try the specific language pattern first (classic Rise)
                let pattern = new RegExp(`__resolveJsonp\\("course:${languageCode}",\\s*"([^"]+)"\\)`);
                let match = jsContent.match(pattern);
                console.log(`üîç Pattern 1 (course:${languageCode}):`, match ? 'FOUND' : 'NOT FOUND');
                
                // Try generic patterns if specific doesn't work (classic Rise)
                if (!match) {
                    pattern = /__resolveJsonp\([^,]+,\s*"([^"]+)"/;
                    match = jsContent.match(pattern);
                    console.log('üîç Pattern 2 (generic __resolveJsonp):', match ? 'FOUND' : 'NOT FOUND');
                }
                
                // Try modern webpack Rise pattern (wpRiseJsonp)
                if (!match) {
                    pattern = /wpRiseJsonp.*?"([A-Za-z0-9+/]{100,}={0,2})"/;
                    match = jsContent.match(pattern);
                    console.log('üîç Pattern 3 (wpRiseJsonp):', match ? 'FOUND' : 'NOT FOUND');
                }
                
                // Try to find course data in JSON format directly (modern webpack Rise)
                if (!match) {
                    console.log('üîç Pattern 4 (direct course JSON): Searching for webpack course data...');
                    
                    // Look for various webpack-style course data patterns
                    const patterns = [
                        // Pattern 1: course object with lessons
                        /"course"\s*:\s*\{[^}]*"lessons"\s*:\s*\[/,
                        // Pattern 2: lessons array directly
                        /"lessons"\s*:\s*\[\s*\{[^}]*"title"/,
                        // Pattern 3: course title pattern
                        /"title"\s*:\s*"[^"]*"[^}]*"lessons"\s*:\s*\[/,
                        // Pattern 4: webpack module with course data
                        /\{[^}]*"course"\s*:\s*\{[^}]*"title"/
                    ];
                    
                    let courseMatch = null;
                    let patternIndex = -1;
                    
                    for (let i = 0; i < patterns.length; i++) {
                        courseMatch = jsContent.match(patterns[i]);
                        if (courseMatch) {
                            patternIndex = i + 1;
                            console.log(`‚úÖ Found course pattern ${patternIndex}:`, courseMatch[0].substring(0, 100) + '...');
                            break;
                        }
                    }
                    
                    if (courseMatch) {
                        console.log('üîç Pattern 4 (direct course JSON): FOUND');
                        
                        // Try different extraction strategies based on the pattern found
                        let courseData = null;
                        const matchIndex = jsContent.indexOf(courseMatch[0]);
                        
                        if (patternIndex === 1 || patternIndex === 4) {
                            // Extract the full object containing the course
                            let startIndex = matchIndex;
                            // Find the start of the object
                            while (startIndex > 0 && jsContent[startIndex] !== '{') {
                                startIndex--;
                            }
                            
                            let braceCount = 0;
                            let endIndex = startIndex;
                            
                            for (let i = startIndex; i < jsContent.length; i++) {
                                if (jsContent[i] === '{') braceCount++;
                                if (jsContent[i] === '}') braceCount--;
                                if (braceCount === 0 && i > startIndex) {
                                    endIndex = i;
                                    break;
                                }
                            }
                            
                            if (endIndex > startIndex) {
                                courseData = jsContent.substring(startIndex, endIndex + 1);
                            }
                        } else {
                            // For lessons array patterns, try to extract a larger context
                            let startIndex = matchIndex - 200; // Go back to find more context
                            let endIndex = matchIndex + 5000; // Take a reasonable chunk
                            
                            startIndex = Math.max(0, startIndex);
                            endIndex = Math.min(jsContent.length, endIndex);
                            
                            const chunk = jsContent.substring(startIndex, endIndex);
                            
                            // Try to find a complete JSON object in this chunk
                            const objectMatch = chunk.match(/\{[^}]*"lessons"\s*:\s*\[[^\]]*\]/);
                            if (objectMatch) {
                                courseData = objectMatch[0] + '}'; // Close the object
                            }
                        }
                        
                        if (courseData) {
                            console.log('üì¶ Extracted course data directly:', courseData.length, 'characters');
                            console.log('üì¶ Course data preview:', courseData.substring(0, 200) + '...');
                            
                            try {
                                const parsedData = JSON.parse(courseData);
                                console.log('‚úÖ Direct JSON parsing successful');
                                console.log('üìö Parsed data keys:', Object.keys(parsedData));
                                
                                const courseContent = parsedData.course || parsedData;
                                console.log('üìö Course title:', courseContent.title || 'No title found');
                                console.log('üìö Lessons count:', courseContent.lessons?.length || 0);
                                
                                this.updateProgress(70);
                                return await this.parseRiseContent(courseContent);
                                
                            } catch (directParseError) {
                                console.log('‚ùå Direct JSON parsing failed:', directParseError.message);
                                console.log('üîç Trying to fix JSON syntax...');
                                
                                // Try to fix common JSON issues
                                let fixedData = courseData
                                    .replace(/,\s*}/g, '}')  // Remove trailing commas
                                    .replace(/,\s*]/g, ']')   // Remove trailing commas in arrays
                                    .replace(/([{,]\s*)(\w+):/g, '$1"$2":'); // Quote unquoted keys
                                
                                try {
                                    const fixedParsedData = JSON.parse(fixedData);
                                    console.log('‚úÖ Fixed JSON parsing successful');
                                    const courseContent = fixedParsedData.course || fixedParsedData;
                                    this.updateProgress(70);
                                    return await this.parseRiseContent(courseContent);
                                } catch (fixedParseError) {
                                    console.log('‚ùå Fixed JSON parsing also failed:', fixedParseError.message);
                                }
                            }
                        }
                    } else {
                        console.log('üîç Pattern 4 (direct course JSON): NOT FOUND');
                    }
                }
                
                // Try even more generic base64 pattern
                if (!match) {
                    pattern = /"([A-Za-z0-9+/]{100,}={0,2})"/;
                    match = jsContent.match(pattern);
                    console.log('üîç Pattern 5 (base64-like):', match ? 'FOUND' : 'NOT FOUND');
                }
                
                if (!match) {
                    console.error('‚ùå No matching pattern found in webpack bundle. This appears to be a very modern Rise course.');
                    console.log('üîç Analyzing webpack bundle structure...');
                    
                    // Try to find course data in the webpack bundle using alternative methods
                    const alternativeExtraction = await this.extractFromWebpackBundle(jsContent);
                    if (alternativeExtraction) {
                        console.log('‚úÖ Successfully extracted from webpack bundle');
                        return alternativeExtraction;
                    }
                    
                    console.error('‚ùå Could not extract from webpack bundle either.');
                    console.log('üìÑ JS content sample for debugging:', jsContent.substring(0, 1000));
                    
                    // Let's see what other files might contain the actual course data
                    console.log('üîç This might be a split webpack bundle. Checking other files...');
                    
                    // Check if there are other files that might contain the actual course content
                    for (const filePath of riseLibFiles) {
                        if (filePath !== localesFile) {
                            const otherFile = zip.files[filePath];
                            const otherContent = await otherFile.async('text');
                            
                            // Look for different patterns in other files
                            if (otherContent.includes('lessons') && otherContent.includes('title') && otherContent.length > 10000) {
                                console.log(`üéØ Found potential course data in alternative file: ${filePath}`);
                                console.log(`üìÑ Content preview:`, otherContent.substring(0, 300));
                                
                                const altExtraction = await this.extractFromWebpackBundle(otherContent);
                                if (altExtraction) {
                                    console.log('‚úÖ Successfully extracted from alternative file');
                                    return altExtraction;
                                }
                            }
                        }
                    }
                    
                    throw new Error('Could not find course data in any webpack bundle files. This may be a newer Rise format that requires different extraction methods.');
                }
                
                const compressedData = match[1];
                console.log(`üì¶ Found compressed data: ${compressedData.length} characters`);
                console.log(`üì¶ Compressed data preview: ${compressedData.substring(0, 100)}...`);
                this.updateProgress(60);
                
                // Decompress and parse
                console.log('üîÑ Attempting LZW decompression...');
                try {
                    const decompressedData = this.lzwDecompress(compressedData);
                    console.log(`‚úÖ Decompression successful: ${decompressedData.length} characters`);
                    console.log(`üìÑ Decompressed preview: ${decompressedData.substring(0, 200)}...`);
                    
                    console.log('üîÑ Parsing JSON...');
                    const parsedData = JSON.parse(decompressedData);
                    console.log('‚úÖ JSON parsing successful');
                    console.log('üìä Parsed data keys:', Object.keys(parsedData));
                    
                    const courseData = parsedData.course || parsedData;
                    console.log('üìö Course data keys:', Object.keys(courseData));
                    console.log('üìö Course title:', courseData.title);
                    console.log('üìö Lessons count:', courseData.lessons?.length || 0);
                    
                    this.updateProgress(70);
                    
                    // Extract content
                    console.log('üîÑ Starting content parsing...');
                    return await this.parseRiseContent(courseData);
                    
                } catch (decompressionError) {
                    console.error('‚ùå Decompression failed:', decompressionError);
                    console.log('üîÑ Trying base64 decode instead of LZW...');
                    
                    try {
                        // Try base64 decode instead
                        const base64Decoded = atob(compressedData);
                        console.log(`üì¶ Base64 decoded: ${base64Decoded.length} characters`);
                        
                        const parsedData = JSON.parse(base64Decoded);
                        console.log('‚úÖ Base64 + JSON parsing successful');
                        
                        const courseData = parsedData.course || parsedData;
                        this.updateProgress(70);
                        
                        return await this.parseRiseContent(courseData);
                        
                    } catch (base64Error) {
                        console.error('‚ùå Base64 decode also failed:', base64Error);
                        throw new Error(`Data decompression failed. LZW error: ${decompressionError.message}, Base64 error: ${base64Error.message}`);
                    }
                }
            }
            
            // Extract course data from modern webpack bundles
            async extractFromWebpackBundle(jsContent) {
                console.log('üîß Attempting webpack bundle extraction...');
                
                try {
                    // Method 1: Look for webpack module exports that might contain course data
                    console.log('üîç Method 1: Searching for webpack module exports...');
                    const modulePattern = /(\d+):\s*\([^)]*\)\s*=>\s*\{[^}]*"course"[^}]*"title"/g;
                    let moduleMatch;
                    const potentialModules = [];
                    
                    while ((moduleMatch = modulePattern.exec(jsContent)) !== null) {
                        console.log(`üì¶ Found potential course module: ${moduleMatch[1]}`);
                        potentialModules.push({
                            moduleId: moduleMatch[1],
                            index: moduleMatch.index
                        });
                    }
                    
                    // Method 2: Look for large JSON-like structures in the bundle
                    console.log('üîç Method 2: Searching for JSON-like structures...');
                    const jsonPattern = /\{[^{}]*"title"\s*:\s*"[^"]*"[^{}]*"lessons"\s*:\s*\[/g;
                    let jsonMatch;
                    
                    while ((jsonMatch = jsonPattern.exec(jsContent)) !== null) {
                        console.log('üì¶ Found potential JSON course structure');
                        
                        // Try to extract the complete object
                        let startIndex = jsonMatch.index;
                        let braceCount = 0;
                        let endIndex = startIndex;
                        
                        for (let i = startIndex; i < jsContent.length && i < startIndex + 50000; i++) {
                            if (jsContent[i] === '{') braceCount++;
                            if (jsContent[i] === '}') braceCount--;
                            if (braceCount === 0 && i > startIndex) {
                                endIndex = i;
                                break;
                            }
                        }
                        
                        if (endIndex > startIndex) {
                            const courseData = jsContent.substring(startIndex, endIndex + 1);
                            console.log(`üì¶ Extracted JSON structure: ${courseData.length} characters`);
                            
                            try {
                                const parsedData = JSON.parse(courseData);
                                if (parsedData.lessons && Array.isArray(parsedData.lessons)) {
                                    console.log('‚úÖ Found valid course data with lessons');
                                    return await this.parseRiseContent(parsedData);
                                }
                            } catch (parseError) {
                                console.log('‚ùå JSON parsing failed for extracted structure');
                            }
                        }
                    }
                    
                    // Method 3: Look for string literals that might contain serialized course data
                    console.log('üîç Method 3: Searching for serialized course data...');
                    const stringPattern = /"(\{[^"]*lessons[^"]*\})"/g;
                    let stringMatch;
                    
                    while ((stringMatch = stringPattern.exec(jsContent)) !== null) {
                        console.log('üì¶ Found potential serialized course data');
                        
                        try {
                            // Unescape the string
                            let courseString = stringMatch[1]
                                .replace(/\\"/g, '"')
                                .replace(/\\n/g, '\n')
                                .replace(/\\r/g, '\r')
                                .replace(/\\t/g, '\t');
                            
                            const parsedData = JSON.parse(courseString);
                            if (parsedData.lessons && Array.isArray(parsedData.lessons)) {
                                console.log('‚úÖ Found valid serialized course data');
                                return await this.parseRiseContent(parsedData);
                            }
                        } catch (parseError) {
                            console.log('‚ùå Failed to parse serialized data');
                        }
                    }
                    
                    // Method 4: Look for base64 encoded data that might be hidden in the bundle
                    console.log('üîç Method 4: Searching for encoded data...');
                    const base64Pattern = /"([A-Za-z0-9+/]{500,}={0,2})"/g;
                    let base64Match;
                    
                    while ((base64Match = base64Pattern.exec(jsContent)) !== null) {
                        console.log(`üì¶ Found potential base64 data: ${base64Match[1].length} characters`);
                        
                        try {
                            // Try base64 decode
                            const decoded = atob(base64Match[1]);
                            console.log(`üì¶ Decoded to: ${decoded.length} characters`);
                            
                            if (decoded.includes('lessons') && decoded.includes('title')) {
                                const parsedData = JSON.parse(decoded);
                                const courseData = parsedData.course || parsedData;
                                if (courseData.lessons && Array.isArray(courseData.lessons)) {
                                    console.log('‚úÖ Found valid base64 encoded course data');
                                    return await this.parseRiseContent(courseData);
                                }
                            }
                        } catch (decodeError) {
                            // Not valid base64 or JSON, continue
                        }
                    }
                    
                    console.log('‚ùå No course data found in webpack bundle');
                    return null;
                    
                } catch (error) {
                    console.error('‚ùå Error during webpack bundle extraction:', error);
                    return null;
                }
            }
            
            async extractScorm12Storyline(zip) {
                // Extract basic information from manifest
                const manifestFile = zip.files['imsmanifest.xml'];
                if (!manifestFile) {
                    throw new Error('Could not find imsmanifest.xml file');
                }
                
                const manifestContent = await manifestFile.async('text');
                this.updateProgress(50);
                
                // Parse XML to extract title
                const parser = new DOMParser();
                const xmlDoc = parser.parseFromString(manifestContent, 'text/xml');
                const titleElement = xmlDoc.querySelector('title langstring');
                const courseTitle = titleElement ? titleElement.textContent : 'Storyline Course';
                
                this.updateProgress(60);
                
                // Check if there are any extractable content files
                let content = [`# ${courseTitle}\n`];
                
                // Look for story content files
                const storyHtml = zip.files['story.html'];
                if (storyHtml) {
                    content.push('## Course Content\n');
                    content.push('**Format:** Interactive Storyline Course');
                    content.push('**File:** story.html');
                    
                    // Try to extract any readable content from story.html
                    try {
                        const storyContent = await storyHtml.async('text');
                        const storyParser = new DOMParser();
                        const storyDoc = storyParser.parseFromString(storyContent, 'text/html');
                        
                        // Look for any text content in the HTML
                        const textElements = storyDoc.querySelectorAll('title, h1, h2, h3, h4, h5, h6, p');
                        textElements.forEach(element => {
                            const text = element.textContent?.trim();
                            if (text && text.length > 3 && !text.includes('javascript') && !text.includes('function')) {
                                content.push(`\n**${element.tagName}:** ${text}`);
                            }
                        });
                    } catch (error) {
                        console.log('Could not extract story.html content:', error);
                    }
                }
                
                // Check for PDF resources
                const pdfFiles = [];
                for (const filePath in zip.files) {
                    if (filePath.endsWith('.pdf')) {
                        const fileName = filePath.split('/').pop();
                        pdfFiles.push(fileName);
                    }
                }
                
                if (pdfFiles.length > 0) {
                    content.push('\n## Additional Resources\n');
                    pdfFiles.forEach(pdf => {
                        content.push(`**PDF Resource:** ${pdf}`);
                    });
                }
                
                this.updateProgress(80);
                
                // Note about Storyline content
                content.push('\n## Note\n');
                content.push('This is a Storyline-based interactive course. The full interactive content, slides, and animations are contained within the Storyline player and cannot be fully extracted as text. To experience the complete course content, the SCORM package should be deployed in a compatible LMS or Storyline player.');
                
                return content.join('\n');
            }
            
            async extractScorm12Flash(zip) {
                // Extract basic information from manifest
                const manifestFile = zip.files['imsmanifest.xml'];
                if (!manifestFile) {
                    throw new Error('Could not find imsmanifest.xml file');
                }
                
                const manifestContent = await manifestFile.async('text');
                this.updateProgress(50);
                
                // Parse XML to extract basic course information
                const parser = new DOMParser();
                const xmlDoc = parser.parseFromString(manifestContent, 'text/xml');
                const titleElement = xmlDoc.querySelector('title');
                let courseTitle = titleElement ? titleElement.textContent : 'Flash-based Course';
                
                // Try to get the actual course title from JavaScript configuration
                const scormUtilsFile = zip.files['SCORM_utilities.js'];
                if (scormUtilsFile) {
                    try {
                        const jsContent = await scormUtilsFile.async('text');
                        const titleMatch = jsContent.match(/COURSETITLE\s*:\s*"([^"]+)"/);
                        if (titleMatch && titleMatch[1] !== 'COURSE_TITLE') {
                            courseTitle = titleMatch[1];
                        }
                    } catch (error) {
                        console.log('Could not extract title from SCORM_utilities.js:', error);
                    }
                }
                
                // Get the main HTML file from the manifest
                const resourceElement = xmlDoc.querySelector('resource[type="webcontent"]');
                const mainHtmlFile = resourceElement ? resourceElement.getAttribute('href') : null;
                
                this.updateProgress(60);
                
                let content = [`# ${courseTitle}\n`];
                
                // Add format information
                content.push('## Course Information\n');
                content.push('**Format:** Flash-based SCORM 1.2 (Adobe Captivate/Flash)');
                if (mainHtmlFile) {
                    content.push(`**Main File:** ${mainHtmlFile}`);
                }
                
                // Analyze and list files with enhanced information
                const swfFiles = [];
                const mediaFiles = [];
                const jsFiles = [];
                let totalSize = 0;
                
                for (const filePath in zip.files) {
                    const file = zip.files[filePath];
                    const size = file._data ? file._data.uncompressedSize : 0;
                    totalSize += size;
                    
                    if (filePath.endsWith('.swf')) {
                        swfFiles.push({path: filePath, size: size});
                    } else if (filePath.match(/\.(flv|mp4|mp3|wav|jpg|jpeg|png|gif)$/i)) {
                        mediaFiles.push({path: filePath, size: size});
                    } else if (filePath.endsWith('.js') && !filePath.includes('standard') && !filePath.includes('browser')) {
                        jsFiles.push({path: filePath, size: size});
                    }
                }
                
                // Add package size information
                content.push(`**Package Size:** ${Math.round(totalSize / 1024)}KB total`);
                
                if (swfFiles.length > 0) {
                    content.push('\n## Flash Content Files\n');
                    // Sort by size (largest first)
                    swfFiles.sort((a, b) => b.size - a.size);
                    swfFiles.forEach(file => {
                        const filename = file.path.split('/').pop();
                        const sizeKB = Math.round(file.size / 1024);
                        const sizeInfo = sizeKB > 0 ? ` (${sizeKB}KB)` : '';
                        content.push(`‚Ä¢ **${filename}**${sizeInfo}`);
                    });
                }
                
                if (mediaFiles.length > 0) {
                    content.push('\n## Media Files\n');
                    // Sort by size (largest first)
                    mediaFiles.sort((a, b) => b.size - a.size);
                    mediaFiles.forEach(file => {
                        const filename = file.path.split('/').pop();
                        const sizeKB = Math.round(file.size / 1024);
                        const sizeInfo = sizeKB > 0 ? ` (${sizeKB}KB)` : '';
                        const extension = filename.split('.').pop().toUpperCase();
                        content.push(`‚Ä¢ **${filename}** (${extension})${sizeInfo}`);
                    });
                }
                
                // Try to extract any text content from the main HTML file
                if (mainHtmlFile && zip.files[mainHtmlFile]) {
                    try {
                        const htmlContent = await zip.files[mainHtmlFile].async('text');
                        const htmlDoc = parser.parseFromString(htmlContent, 'text/html');
                        
                        // Look for any visible text content
                        const textElements = htmlDoc.querySelectorAll('title, h1, h2, h3, h4, h5, h6, p, div');
                        const extractedText = [];
                        
                        textElements.forEach(element => {
                            const text = element.textContent?.trim();
                            if (text && text.length > 3 && 
                                !text.includes('javascript') && 
                                !text.includes('function') &&
                                !text.includes('Adobe') &&
                                !text.includes('Flash') &&
                                !extractedText.includes(text)) {
                                extractedText.push(text);
                            }
                        });
                        
                        if (extractedText.length > 0) {
                            content.push('\n## Extracted Text Content\n');
                            extractedText.forEach(text => {
                                content.push(`‚Ä¢ ${text}`);
                            });
                        }
                    } catch (error) {
                        console.log('Could not extract HTML content:', error);
                    }
                }
                
                // Analyze JavaScript files for additional content
                if (scormUtilsFile) {
                    try {
                        const jsContent = await scormUtilsFile.async('text');
                        
                        // Extract configuration information
                        const configMatches = {
                            bgcolor: jsContent.match(/BGCOLOR\s*:\s*"([^"]+)"/),
                            width: jsContent.match(/COURSE_WIDTH\s*:\s*"([^"]+)"/),
                            height: jsContent.match(/COURSE_HEIGHT\s*:\s*"([^"]+)"/),
                            fpversion: jsContent.match(/FPVERSION\s*:\s*"([^"]+)"/),
                        };
                        
                        const hasConfig = Object.values(configMatches).some(match => match);
                        if (hasConfig) {
                            content.push('\n## Technical Configuration\n');
                            if (configMatches.fpversion && configMatches.fpversion[1]) {
                                content.push(`‚Ä¢ **Flash Player Version:** ${configMatches.fpversion[1]}`);
                            }
                            if (configMatches.width && configMatches.width[1]) {
                                content.push(`‚Ä¢ **Course Dimensions:** ${configMatches.width[1]} √ó ${configMatches.height?.[1] || 'auto'}`);
                            }
                            if (configMatches.bgcolor && configMatches.bgcolor[1]) {
                                content.push(`‚Ä¢ **Background Color:** ${configMatches.bgcolor[1]}`);
                            }
                        }
                        
                        // Look for interaction types mentioned in the code
                        const interactionTypes = [];
                        if (jsContent.includes('RecordMultipleChoiceInteraction')) {
                            interactionTypes.push('Multiple Choice Questions');
                        }
                        if (jsContent.includes('RecordTrueFalseInteraction')) {
                            interactionTypes.push('True/False Questions');
                        }
                        if (jsContent.includes('RecordMatchingInteraction')) {
                            interactionTypes.push('Matching Activities');
                        }
                        if (jsContent.includes('RecordSequencingInteraction')) {
                            interactionTypes.push('Sequencing Activities');
                        }
                        if (jsContent.includes('RecordFillInInteraction')) {
                            interactionTypes.push('Fill-in-the-Blank');
                        }
                        
                        if (interactionTypes.length > 0) {
                            content.push('\n## Detected Interaction Types\n');
                            interactionTypes.forEach(type => {
                                content.push(`‚Ä¢ ${type}`);
                            });
                        }
                        
                    } catch (error) {
                        console.log('Could not analyze SCORM_utilities.js:', error);
                    }
                }
                
                // Check metadata file for additional information
                const metadataFile = zip.files['metadata.xml'];
                if (metadataFile) {
                    try {
                        const metadataContent = await metadataFile.async('text');
                        const metadataDoc = parser.parseFromString(metadataContent, 'text/xml');
                        
                        const description = metadataDoc.querySelector('description langstring');
                        if (description && description.textContent && 
                            !description.textContent.includes('INSERT PROJECT DESCRIPTION')) {
                            content.push('\n## Course Description\n');
                            content.push(description.textContent.trim());
                        }
                        
                        const keywords = metadataDoc.querySelectorAll('keyword langstring');
                        if (keywords.length > 0) {
                            content.push('\n## Keywords\n');
                            keywords.forEach(keyword => {
                                if (keyword.textContent && keyword.textContent.trim()) {
                                    content.push(`‚Ä¢ ${keyword.textContent.trim()}`);
                                }
                            });
                        }
                    } catch (error) {
                        console.log('Could not extract metadata:', error);
                    }
                }
                
                this.updateProgress(80);
                
                // Add important note about Flash content
                content.push('\n## ‚ö†Ô∏è Important Note\n');
                content.push('This is a Flash-based SCORM package (likely created with Adobe Captivate). The actual course content, interactions, and assessments are compiled into Flash (.swf) files and cannot be extracted as text.');
                content.push('\n**To access the full content:**');
                content.push('‚Ä¢ Deploy the SCORM package in a compatible LMS');
                content.push('‚Ä¢ Use a Flash-compatible browser or Flash player');
                content.push('‚Ä¢ Consider converting to HTML5 format for modern compatibility');
                
                return content.join('\n');
            }
            
            async extractScorm2004(zip) {
                // Store zip reference for PDF transcript extraction
                this.currentZip = zip;
                // Initialize transcript cache for this extraction
                this.transcriptCache = new Map();
                
                const searchIndexFile = zip.files['scormcontent/search_index.json'];
                if (!searchIndexFile) {
                    throw new Error('Could not find search_index.json file');
                }
                
                const searchIndexContent = await searchIndexFile.async('text');
                const searchData = JSON.parse(searchIndexContent);
                this.updateProgress(60);
                
                if (!searchData.store) {
                    throw new Error('Invalid search index structure');
                }
                
                let content = ['# Course Content\n'];
                let processedCount = 0;
                const totalDocs = Object.keys(searchData.store).length;
                
                for (const [docId, docObject] of Object.entries(searchData.store)) {
                    const title = docObject.title || 'Untitled Section';
                    const url = docObject.url || '';
                    
                    content.push(`\n## ${title}\n`);
                    
                    if (url && !url.endsWith('/')) {
                        const htmlPath = `scormcontent/${url.replace(/^\//, '')}`;
                        const htmlFile = zip.files[htmlPath];
                        
                        if (htmlFile) {
                            const htmlContent = await htmlFile.async('text');
                            const cleanedContent = this.cleanHtmlText(htmlContent);
                            if (cleanedContent) {
                                content.push(cleanedContent);
                            }
                        }
                    }
                    
                    processedCount++;
                    this.updateProgress(60 + (processedCount / totalDocs) * 20);
                }
                
                return content.join('\n\n').trim();
            }
            
            async parseRiseContent(courseData) {
                let content = [`# ${courseData.title || 'Course Content'}\n`];
                
                // Initialize broken URLs collection (always reset for new extraction)
                window.brokenUrls = new Set();
                
                // Initialize image locations tracking (always reset for new extraction)
                window.imageLocations = [];
                
                // Collect all transcript attachments first (always reset for new extraction)
                this.transcriptAttachments = new Map();
                this.videoItems = [];
                
                // First pass: collect all transcript attachments and video items from all lessons
                if (courseData.lessons && Array.isArray(courseData.lessons)) {
                    console.log('üîç Starting transcript collection from', courseData.lessons.length, 'lessons');
                    for (const lesson of courseData.lessons) {
                        console.log('üìñ Processing lesson:', lesson.title, 'with', lesson.items?.length || 0, 'items');
                        if (lesson.items && Array.isArray(lesson.items)) {
                            console.log(`üìä Processing lesson "${lesson.title}" with ${lesson.items.length} items for duration`);
                            for (const item of lesson.items) {
                                console.log(`üìä Item type: ${item.type}, has media: ${!!item.media}, has embed: ${!!(item.media && item.media.embed)}`);
                                console.log('üîç Checking item:', item.id, 'type:', item.type, 'media:', item.media ? 'yes' : 'no');
                                
                                // For now, skip the complex media population and just collect what we can
                                let mediaContent = item.media;
                                if (mediaContent) {
                                    console.log('  üìé Item has media:', Object.keys(mediaContent));
                                }
                                if (mediaContent?.attachment && 
                                    (mediaContent.attachment.filename?.toLowerCase().includes('transcript') || 
                                     mediaContent.attachment.originalUrl?.toLowerCase().includes('transcript'))) {
                                    console.log('üìé Found transcript attachment:', mediaContent.attachment.originalUrl);
                                    this.transcriptAttachments.set(mediaContent.attachment.originalUrl, {
                                        item: item,
                                        lesson: lesson.title,
                                        attachment: mediaContent.attachment
                                    });
                                }
                                
                                // Debug multimedia items specifically
                                if (item.type === 'multimedia' && mediaContent) {
                                    console.log('üé¨ Multimedia item found:', item.id, 'media keys:', Object.keys(mediaContent));
                                    if (mediaContent.attachment) {
                                        console.log('  üìé Has attachment:', mediaContent.attachment.filename);
                                    }
                                    if (mediaContent.embed) {
                                        console.log('  üé• Has embed');
                                    }
                                }
                                if (mediaContent?.embed) {
                                    console.log('üé• Found video item:', item.id);
                                    this.videoItems.push({
                                        item: item,
                                        lesson: lesson.title
                                    });
                                }
                            }
                        }
                    }
                }
                
                console.log(`üìö Collected ${this.transcriptAttachments.size} transcript attachments and ${this.videoItems.length} video items`);
                
                // Second pass: process lessons and content
                if (courseData.lessons && Array.isArray(courseData.lessons)) {
                    for (const lesson of courseData.lessons) {
                        if (lesson.title) {
                            content.push(`\n## ${lesson.title}\n`);
                        }
                        
                        // Handle quiz lessons differently
                        if (lesson.type === 'quiz' && lesson.items && Array.isArray(lesson.items)) {
                            console.log('Processing quiz lesson with', lesson.items.length, 'questions');
                            const quizContent = this.parseQuizLesson(lesson);
                            if (quizContent) {
                                content.push(quizContent);
                            }
                        } else if (lesson.items && Array.isArray(lesson.items)) {
                            const lessonContent = await this.parseRiseLessonItems(lesson.items, lesson.title || '');
                            if (lessonContent) {
                                content.push(lessonContent);
                            }
                        }
                    }
                }
                
                // Generate asset inventory and content analysis
                const assetInventory = this.generateAssetInventory();
                const contentBreakdown = this.generateContentBreakdown(courseData);
                console.log('üìä Starting duration estimation...');
                const durationEstimate = this.estimateCourseDuration(courseData);
                console.log('üìä Duration estimation complete');
                
                // Final cleanup: remove any remaining euro symbols from the entire output
                const finalContent = content.join('\n\n').trim().replace(/s‚Ç¨/g, 's').replace(/‚Ç¨/g, '');
                
                // Image locations are now integrated directly into the main content
                
                // Add broken URLs section if any were found
                let brokenUrlsSection = '';
                if (window.brokenUrls && window.brokenUrls.size > 0) {
                    const urlList = Array.from(window.brokenUrls).map(url => `- ${url}`).join('\n');
                    brokenUrlsSection = `\n\n### üîó Broken URLs Found\n\nThe following URLs were found to be corrupted during processing:\n\n${urlList}\n\n**Note:** These URLs may need manual correction in the final content.`;
                }
                
                // Add analysis sections to the output
                const analysisContent = [
                    '\n\n---\n\n',
                    '## üìä Course Analysis\n\n',
                    '### üìÇ How to Access Course Assets\n\n',
                    '**To access the images and files listed below:**\n',
                    '1. Open the original SCORM zip file\n',
                    '2. Navigate to the `scormcontent` folder\n',
                    '3. Open the `assets` folder\n',
                    '4. All images, PDFs, and media files should be located in this folder\n\n',
                    '**Note:** Some files may be in subfolders within the assets directory. Use the file paths shown in the inventory below to locate specific files.\n\n',
                    '### üìÅ Asset Inventory\n',
                    assetInventory,
                    '\n\n### üìà Content Type Breakdown\n',
                    contentBreakdown,
                    '\n\n### ‚è±Ô∏è Estimated Duration\n',
                    durationEstimate,
                    brokenUrlsSection
                ].join('');
                
                return finalContent + analysisContent;
            }
            
            // Generate comprehensive asset inventory from ZIP file
            generateAssetInventory() {
                if (!this.currentZip) return 'No ZIP file available for analysis.';
                
                const assets = [];
                let totalSize = 0;
                
                // Collect only PDF, PNG, and JPG files from the ZIP
                for (const [filename, file] of Object.entries(this.currentZip.files)) {
                    if (!file.dir) { // Skip directories
                        const extension = filename.split('.').pop()?.toLowerCase() || 'unknown';
                        
                        // Only include PDF, PNG, and JPG files
                        if (['pdf', 'png', 'jpg', 'jpeg'].includes(extension)) {
                            const size = file._data.uncompressedSize || 0;
                            const sizeKB = (size / 1024).toFixed(1);
                            
                            assets.push({
                                filename,
                                size: sizeKB,
                                type: extension,
                                path: filename
                            });
                            
                            totalSize += size;
                        }
                    }
                }
                
                // Sort by size (largest first)
                assets.sort((a, b) => parseFloat(b.size) - parseFloat(a.size));
                
                // Group by file type
                const typeGroups = {};
                assets.forEach(asset => {
                    if (!typeGroups[asset.type]) {
                        typeGroups[asset.type] = [];
                    }
                    typeGroups[asset.type].push(asset);
                });
                
                let output = `**Total Assets:** ${assets.length} files (${(totalSize / 1024 / 1024).toFixed(2)} MB)\n\n`;
                
                // Output by type
                for (const [type, files] of Object.entries(typeGroups)) {
                    const typeSize = files.reduce((sum, file) => sum + parseFloat(file.size), 0);
                    output += `**${type.toUpperCase()} Files (${files.length}):** ${typeSize.toFixed(1)} KB\n`;
                    
                    files.forEach(file => {
                        output += `- ${file.filename} (${file.size} KB)\n`;
                    });
                    output += '\n';
                }
                
                return output;
            }
            
            // Generate content type breakdown
            generateContentBreakdown(courseData) {
                if (!courseData.lessons) return 'No lesson data available for analysis.';
                
                let totalItems = 0;
                let textItems = 0;
                let videoItems = 0;
                let audioItems = 0;
                let imageItems = 0;
                let interactiveItems = 0;
                let quizItems = 0;
                let otherItems = 0;
                
                // Count items by type from JSON structure
                courseData.lessons.forEach(lesson => {
                    if (lesson.items) {
                        lesson.items.forEach(item => {
                            totalItems++;
                            
                            switch (item.type) {
                                case 'text':
                                    textItems++;
                                    break;
                                case 'multimedia':
                                    if (item.media?.embed) videoItems++;
                                    else if (item.media?.audio) audioItems++;
                                    else if (item.media?.image) imageItems++;
                                    else otherItems++;
                                    break;
                                case 'interactive':
                                    interactiveItems++;
                                    break;
                                case 'knowledgeCheck':
                                case 'quiz':
                                    quizItems++;
                                    break;
                                default:
                                    otherItems++;
                            }
                        });
                    }
                });
                
                // Also count images from ZIP file assets
                if (this.currentZip) {
                    let zipImageCount = 0;
                    for (const [filename, file] of Object.entries(this.currentZip.files)) {
                        if (!file.dir) {
                            const extension = filename.split('.').pop()?.toLowerCase() || '';
                            if (['jpg', 'jpeg', 'png', 'gif', 'bmp', 'svg', 'webp'].includes(extension)) {
                                zipImageCount++;
                            }
                        }
                    }
                    // Use the higher count between JSON structure and ZIP files
                    imageItems = Math.max(imageItems, zipImageCount);
                }
                
                const output = [
                    `**Total Content Items:** ${totalItems}\n`,
                    `**Text Content:** ${textItems} (${((textItems / totalItems) * 100).toFixed(1)}%)\n`,
                    `**Video Content:** ${videoItems} (${((videoItems / totalItems) * 100).toFixed(1)}%)\n`,
                    `**Audio Content:** ${audioItems} (${((audioItems / totalItems) * 100).toFixed(1)}%)\n`,
                    `**Image Content:** ${imageItems} (${((imageItems / totalItems) * 100).toFixed(1)}%)\n`,
                    `**Interactive Content:** ${interactiveItems} (${((interactiveItems / totalItems) * 100).toFixed(1)}%)\n`,
                    `**Quiz/Assessment:** ${quizItems} (${((quizItems / totalItems) * 100).toFixed(1)}%)\n`,
                    `**Other Content:** ${otherItems} (${((otherItems / totalItems) * 100).toFixed(1)}%)\n`
                ].join('');
                
                return output;
            }
            
            // Estimate course duration based on content
            estimateCourseDuration(courseData) {
                if (!courseData.lessons) return 'No lesson data available for duration estimation.';
                
                let totalWords = 0;
                let totalVideoDuration = 0;
                let totalAudioDuration = 0;
                let lessonBreakdown = [];
                
                courseData.lessons.forEach(lesson => {
                    let lessonWords = 0;
                    let lessonVideoDuration = 0;
                    let lessonAudioDuration = 0;
                    
                    if (lesson.items) {
                        lesson.items.forEach(item => {
                            // Count words in text content
                            if (item.type === 'text' && item.items) {
                                item.items.forEach(textItem => {
                                    if (textItem.heading) {
                                        lessonWords += textItem.heading.split(' ').length;
                                    }
                                    if (textItem.paragraph) {
                                        lessonWords += textItem.paragraph.split(' ').length;
                                    }
                                });
                            }
                            
                            // Estimate video/audio duration from transcripts
                            if (item.type === 'multimedia') {
                                // Since media is not populated in raw courseData, estimate based on type
                                // Use a default estimate for multimedia items
                                console.log('üé• Video duration calculation:', {
                                    itemId: item.id,
                                    itemType: item.type,
                                    hasMedia: !!item.media,
                                    usingDefaultEstimate: !item.media
                                });
                                
                                if (item.media && item.media.embed) {
                                    // If media is available, try to get transcript
                                    const transcriptText = this.getTranscriptForItem(item);
                                    if (transcriptText) {
                                        const transcriptWords = transcriptText.split(' ').length;
                                        const transcriptMinutes = transcriptWords / 150; // 150 words per minute
                                        lessonVideoDuration += Math.max(transcriptMinutes, 1); // Minimum 1 minute
                                    } else {
                                        lessonVideoDuration += 2.5; // Default video estimate
                                    }
                                } else {
                                    // Default estimate for multimedia without populated media
                                    lessonVideoDuration += 2.5; // 2.5 minutes per multimedia item
                                }
                                if (item.media && item.media.audio) {
                                    // Check if this item has a transcript attachment
                                    const transcriptText = this.getTranscriptForItem(item);
                                    if (transcriptText) {
                                        const transcriptWords = transcriptText.split(' ').length;
                                        const transcriptMinutes = transcriptWords / 150; // 150 words per minute
                                        lessonAudioDuration += Math.max(transcriptMinutes, 0.5); // Minimum 0.5 minutes
                                    } else {
                                        // Estimate 1-2 minutes for typical audio content
                                        lessonAudioDuration += 1.5;
                                    }
                                }
                            }
                        });
                    }
                    
                    totalWords += lessonWords;
                    totalVideoDuration += lessonVideoDuration;
                    totalAudioDuration += lessonAudioDuration;
                    
                    const lessonTextMinutes = lessonWords / 150; // 150 words per minute
                    const lessonTotalMinutes = lessonTextMinutes + lessonVideoDuration + lessonAudioDuration;
                    
                    lessonBreakdown.push({
                        title: lesson.title || 'Untitled Lesson',
                        textMinutes: lessonTextMinutes.toFixed(1),
                        videoMinutes: lessonVideoDuration.toFixed(1),
                        audioMinutes: lessonAudioDuration.toFixed(1),
                        totalMinutes: lessonTotalMinutes.toFixed(1)
                    });
                });
                
                const totalTextMinutes = totalWords / 150;
                const totalMinutes = totalTextMinutes + totalVideoDuration + totalAudioDuration;
                const totalHours = Math.floor(totalMinutes / 60);
                const remainingMinutes = Math.round(totalMinutes % 60);
                
                let output = [
                    `**Estimated Total Duration:** ${totalHours}h ${remainingMinutes}m\n`,
                    `**Breakdown:**\n`,
                    `- Text Content: ${totalTextMinutes.toFixed(1)} minutes (${totalWords} words)\n`,
                    `- Video Content: ${totalVideoDuration.toFixed(1)} minutes\n`,
                    `- Audio Content: ${totalAudioDuration.toFixed(1)} minutes\n\n`,
                    `**Per Lesson Breakdown:**\n`
                ].join('');
                
                lessonBreakdown.forEach(lesson => {
                    output += `- **${lesson.title}:** ${lesson.totalMinutes}m (Text: ${lesson.textMinutes}m, Video: ${lesson.videoMinutes}m, Audio: ${lesson.audioMinutes}m)\n`;
                });
                
                return output;
            }
            
            // Get MIME type for file extension
            getMimeType(extension) {
                const mimeTypes = {
                    'png': 'image/png',
                    'jpg': 'image/jpeg',
                    'jpeg': 'image/jpeg',
                    'gif': 'image/gif',
                    'bmp': 'image/bmp',
                    'svg': 'image/svg+xml',
                    'webp': 'image/webp'
                };
                return mimeTypes[extension?.toLowerCase()] || 'image/png';
            }
            
            // Get transcript text for a media item
            getTranscriptForMedia(item) {
                // Check if this item has an associated transcript in the cache
                if (this.transcriptCache) {
                    const mediaTitle = item.media?.embed?.title || item.title || 'video';
                    const lessonTitle = item.lessonTitle || '';
                    const sectionContext = 'video_multimedia';
                    const cacheKey = `${mediaTitle}_${lessonTitle}_${sectionContext}`;
                    
                    return this.transcriptCache.get(cacheKey);
                }
                return null;
            }
            
            // Get transcript text for an item by checking attachments
            getTranscriptForItem(item) {
                console.log('üîç getTranscriptForItem called for item:', item.id, 'type:', item.type);
                
                if (item.media && item.media.attachment) {
                    // Single attachment case
                    const attachment = item.media.attachment;
                    if (attachment.originalUrl && attachment.originalUrl.toLowerCase().includes('transcript')) {
                        console.log('üìÑ Found single transcript attachment:', attachment.originalUrl);
                        return this.extractTranscriptFromAttachmentSync(attachment);
                    }
                } else if (item.media && item.media.attachments) {
                    // Multiple attachments case
                    for (const attachment of item.media.attachments) {
                        if (attachment.title && attachment.title.toLowerCase().includes('transcript')) {
                            console.log('üìÑ Found transcript attachment:', attachment.title);
                            return this.extractTranscriptFromAttachmentSync(attachment);
                        }
                    }
                }
                console.log('‚ùå No transcript found for item');
                return null;
            }
            
            // Synchronous transcript extraction for duration calculation
            extractTranscriptFromAttachmentSync(attachment) {
                const filename = attachment.originalUrl || attachment.title;
                if (!filename || !this.currentZip) return null;
                
                console.log('üîç Extracting transcript from:', filename);
                
                const transcriptPath = `scormcontent/assets/${this.mapOriginalUrlToZipFilename(filename)}`;
                const transcriptFile = this.currentZip.files[transcriptPath];
                
                if (transcriptFile) {
                    console.log('‚úÖ Found transcript file, estimating word count from size');
                    // For duration calculation, we'll use a simple word count estimate
                    // based on the file size (rough approximation)
                    const fileSize = transcriptFile._data.uncompressedSize;
                    const estimatedWords = Math.floor(fileSize / 6); // Rough estimate: 6 bytes per word
                    return ' '.repeat(estimatedWords); // Return spaces to simulate word count
                } else {
                    console.log('‚ùå Transcript file not found at:', transcriptPath);
                }
                
                return null;
            }
            
            // Generic validation for quiz questions - detects structural and logical issues
            validateQuestionLogic(question) {
                const questionText = (question.title || '').toLowerCase();
                const warnings = [];
                
                // Check for obviously contradictory answers
                const correctAnswers = question.answers.filter(answer => 
                    answer.correct || (question.corrects && question.corrects.includes(answer.id))
                );
                
                // Detect potential answer key mapping issues
                if (correctAnswers.length > 0) {
                    const answerTexts = question.answers.map(answer => 
                        (answer.title || answer.html || answer.text || '').toLowerCase()
                    );
                    
                    // Check for contradictory answers both being marked correct
                    for (let i = 0; i < question.answers.length; i++) {
                        for (let j = i + 1; j < question.answers.length; j++) {
                            const answer1 = question.answers[i];
                            const answer2 = question.answers[j];
                            const text1 = (answer1.title || answer1.html || answer1.text || '').toLowerCase();
                            const text2 = (answer2.title || answer2.html || answer2.text || '').toLowerCase();
                            
                            const isCorrect1 = answer1.correct || (question.corrects && question.corrects.includes(answer1.id));
                            const isCorrect2 = answer2.correct || (question.corrects && question.corrects.includes(answer2.id));
                            
                            // Look for contradictory patterns
                            if (isCorrect1 && isCorrect2) {
                                // Check for yes/no contradictions
                                if ((text1.includes('yes') && text2.includes('no')) || 
                                    (text1.includes('true') && text2.includes('false')) ||
                                    (text1.includes('correct') && text2.includes('incorrect'))) {
                                    warnings.push(`‚ùå LIKELY ERROR: Contradictory answers both marked correct: "${answer1.title || answer1.html || answer1.text}" and "${answer2.title || answer2.html || answer2.text}"`);
                                }
                                
                                // Check for opposite quantity patterns
                                if ((text1.includes('all') && text2.includes('none')) ||
                                    (text1.includes('always') && text2.includes('never')) ||
                                    (text1.includes('maximum') && text2.includes('minimum'))) {
                                    warnings.push(`‚ùå LIKELY ERROR: Opposite answers both marked correct: "${answer1.title || answer1.html || answer1.text}" and "${answer2.title || answer2.html || answer2.text}"`);
                                }
                            }
                        }
                    }
                    
                    // Check for suspicious patterns in single-choice questions
                    if (question.type !== 'multipleResponse' && correctAnswers.length === 1) {
                        const correctAnswer = correctAnswers[0];
                        const correctText = (correctAnswer.title || correctAnswer.html || correctAnswer.text || '').toLowerCase();
                        
                        // Look for answers that seem obviously wrong but are marked correct
                        const suspiciousPatterns = [
                            { pattern: /\bnot\s+applicable\b/i, reason: "marked as 'not applicable'" },
                            { pattern: /\bnone\s+of\s+the\s+above\b/i, reason: "marked as 'none of the above' in single-choice" },
                            { pattern: /\bunknown\b/i, reason: "marked as 'unknown'" },
                            { pattern: /\bimpossible\b/i, reason: "marked as 'impossible'" },
                            { pattern: /\bincorrect\b/i, reason: "contains the word 'incorrect'" },
                            { pattern: /\bfalse\b.*\bstatement\b/i, reason: "described as a 'false statement'" },
                            { pattern: /\bnot\s+(true|correct|valid|applicable)\b/i, reason: "explicitly states 'not true/correct/valid'" }
                        ];
                        
                        suspiciousPatterns.forEach(({ pattern, reason }) => {
                            if (pattern.test(correctText)) {
                                warnings.push(`‚ö†Ô∏è SUSPICIOUS: Answer "${correctAnswer.title || correctAnswer.html || correctAnswer.text}" is ${reason} - please verify this is actually correct`);
                            }
                        });
                    }
                    
                    // Check for potential index/position mapping errors
                    // If the first answer is always correct across multiple questions, it might indicate a mapping issue
                    if (question.answers.length > 1) {
                        const firstAnswerCorrect = question.answers[0].correct || (question.corrects && question.corrects.includes(question.answers[0].id));
                        if (firstAnswerCorrect && correctAnswers.length === 1) {
                            // This is just flagged for patterns across multiple questions, handled at quiz level
                        }
                    }
                }
                
                return warnings;
            }

            // Attempt to fix randomization mapping issues
            attemptRandomizationFix(lesson) {
                if (!lesson.items || !Array.isArray(lesson.items)) {
                    return { fixed: false, changes: [] };
                }
                
                const questions = lesson.items.filter(item => item.answers && Array.isArray(item.answers));
                if (questions.length === 0) {
                    return { fixed: false, changes: [] };
                }
                
                const changes = [];
                let totalFixed = 0;
                
                // Check if we have a systematic first-answer-correct pattern
                const firstAnswerCorrectCount = questions.filter(q => {
                    const correctAnswers = q.answers.filter(answer => 
                        answer.correct || (q.corrects && q.corrects.includes(answer.id))
                    );
                    return correctAnswers.length === 1 && 
                           (q.answers[0].correct || (q.corrects && q.corrects.includes(q.answers[0].id)));
                }).length;
                
                // If >70% of questions have first answer correct, likely a mapping issue
                if (firstAnswerCorrectCount > questions.length * 0.7) {
                    changes.push(`üîß **RANDOMIZATION FIX ATTEMPTED**: Detected ${firstAnswerCorrectCount}/${questions.length} questions with first answer marked correct.`);
                    changes.push(`This suggests answer shuffling broke the answer key mapping. Un-SCORM cannot automatically fix this, but here are the likely correct answers based on content analysis:`);
                    changes.push('');
                    
                    questions.forEach((question, qIndex) => {
                        const questionText = (question.title || '').toLowerCase();
                        const suggestedFix = this.suggestCorrectAnswer(question, questionText);
                        
                        if (suggestedFix) {
                            changes.push(`**Question ${qIndex + 1}**: ${question.title || 'Untitled'}`);
                            changes.push(`- Currently marked correct: ${suggestedFix.currentCorrect}`);
                            changes.push(`- Suggested correct: ${suggestedFix.suggestedCorrect}`);
                            changes.push(`- Reason: ${suggestedFix.reason}`);
                            changes.push('');
                            totalFixed++;
                        }
                    });
                }
                
                return { fixed: totalFixed > 0, changes, fixedCount: totalFixed };
            }
            
            // Advanced correct answer detection using multiple methods
            detectCorrectAnswer(question, questionText) {
                const answers = question.answers;
                if (!answers || answers.length === 0) return null;
                
                const currentCorrect = answers.find(answer => 
                    answer.correct || (question.corrects && question.corrects.includes(answer.id))
                );
                
                const detectionResults = [];
                
                // Method 1: Feedback Analysis
                const feedbackResult = this.analyzeAnswerFeedback(question);
                if (feedbackResult) {
                    detectionResults.push({
                        method: "Feedback Analysis",
                        suggestedAnswer: feedbackResult.answer,
                        confidence: feedbackResult.confidence,
                        reason: feedbackResult.reason
                    });
                }
                
                // Method 2: Content Length and Specificity
                const specificityResult = this.analyzeAnswerSpecificity(answers, questionText);
                if (specificityResult) {
                    detectionResults.push({
                        method: "Content Specificity",
                        suggestedAnswer: specificityResult.answer,
                        confidence: specificityResult.confidence,
                        reason: specificityResult.reason
                    });
                }
                
                // Method 3: Keyword Pattern Matching
                const keywordResult = this.analyzeKeywordPatterns(answers, questionText);
                if (keywordResult) {
                    detectionResults.push({
                        method: "Keyword Pattern",
                        suggestedAnswer: keywordResult.answer,
                        confidence: keywordResult.confidence,
                        reason: keywordResult.reason
                    });
                }
                
                // Method 4: Grammatical Structure Analysis
                const grammarResult = this.analyzeGrammaticalFit(answers, questionText);
                if (grammarResult) {
                    detectionResults.push({
                        method: "Grammar Analysis",
                        suggestedAnswer: grammarResult.answer,
                        confidence: grammarResult.confidence,
                        reason: grammarResult.reason
                    });
                }
                
                // Method 5: Numerical/Factual Pattern Detection
                const factualResult = this.analyzeFactualPatterns(answers, questionText);
                if (factualResult) {
                    detectionResults.push({
                        method: "Factual Pattern",
                        suggestedAnswer: factualResult.answer,
                        confidence: factualResult.confidence,
                        reason: factualResult.reason
                    });
                }
                
                // Consolidate results and find consensus
                if (detectionResults.length > 0) {
                    return this.consolidateDetectionResults(detectionResults, currentCorrect);
                }
                
                return null;
            }
            
            // Analyze feedback to determine correct answers
            analyzeAnswerFeedback(question) {
                // Check if feedback mentions specific answers
                const feedback = question.feedback || question.feedbackCorrect || question.feedbackIncorrect || '';
                if (!feedback) return null;
                
                const feedbackText = feedback.toLowerCase();
                
                for (let i = 0; i < question.answers.length; i++) {
                    const answer = question.answers[i];
                    const answerText = (answer.title || answer.html || answer.text || '').toLowerCase();
                    
                    // Look for answer text mentioned in feedback
                    const answerWords = answerText.split(' ').filter(word => word.length > 3);
                    const mentionedWords = answerWords.filter(word => feedbackText.includes(word));
                    
                    if (mentionedWords.length > answerWords.length * 0.5) {
                        return {
                            answer: answer,
                            confidence: 0.8,
                            reason: `Answer text heavily referenced in feedback: "${mentionedWords.join(', ')}"`
                        };
                    }
                }
                
                return null;
            }
            
            // Analyze answer specificity and detail level
            analyzeAnswerSpecificity(answers, questionText) {
                if (questionText.includes('which') || questionText.includes('what') || questionText.includes('how')) {
                    const answersByLength = [...answers].sort((a, b) => {
                        const textA = (a.title || a.html || a.text || '');
                        const textB = (b.title || b.html || b.text || '');
                        return textB.length - textA.length;
                    });
                    
                    const longest = answersByLength[0];
                    const longestText = (longest.title || longest.html || longest.text || '').toLowerCase();
                    
                    // Avoid generic negative answers
                    if (!longestText.includes('none') && 
                        !longestText.includes('not applicable') && 
                        !longestText.includes('impossible') &&
                        longestText.length > 20) {
                        return {
                            answer: longest,
                            confidence: 0.6,
                            reason: "Most detailed and specific answer for descriptive question"
                        };
                    }
                }
                
                return null;
            }
            
            // Analyze keyword patterns between question and answers
            analyzeKeywordPatterns(answers, questionText) {
                const questionWords = questionText.toLowerCase().split(' ')
                    .filter(word => word.length > 3 && !['which', 'what', 'where', 'when', 'how', 'that', 'this', 'with', 'from'].includes(word));
                
                let bestMatch = null;
                let bestScore = 0;
                
                answers.forEach(answer => {
                    const answerText = (answer.title || answer.html || answer.text || '').toLowerCase();
                    const answerWords = answerText.split(' ').filter(word => word.length > 3);
                    
                    // Calculate keyword overlap
                    const matches = questionWords.filter(qWord => 
                        answerWords.some(aWord => aWord.includes(qWord) || qWord.includes(aWord))
                    );
                    
                    const score = matches.length / Math.max(questionWords.length, 1);
                    
                    if (score > bestScore && score > 0.3) {
                        bestScore = score;
                        bestMatch = {
                            answer: answer,
                            confidence: Math.min(0.7, score),
                            reason: `High keyword overlap with question: ${matches.join(', ')}`
                        };
                    }
                });
                
                return bestMatch;
            }
            
            // Analyze grammatical fit between question and answer
            analyzeGrammaticalFit(answers, questionText) {
                // Look for question-answer grammatical consistency
                if (questionText.toLowerCase().includes('is') || questionText.toLowerCase().includes('are')) {
                    // Declarative questions usually want positive, definitive answers
                    for (let answer of answers) {
                        const answerText = (answer.title || answer.html || answer.text || '').toLowerCase();
                        
                        if (!answerText.includes('not') && 
                            !answerText.includes('no') && 
                            !answerText.includes('none') &&
                            !answerText.includes('never') &&
                            answerText.length > 10) {
                            return {
                                answer: answer,
                                confidence: 0.5,
                                reason: "Positive, definitive answer fits declarative question structure"
                            };
                        }
                    }
                }
                
                return null;
            }
            
            // Analyze factual and numerical patterns
            analyzeFactualPatterns(answers, questionText) {
                // Look for numerical questions
                if (questionText.includes('how many') || questionText.includes('how long') || questionText.includes('years')) {
                    const numericalAnswers = answers.filter(answer => {
                        const text = (answer.title || answer.html || answer.text || '');
                        return /\d+/.test(text);
                    });
                    
                    if (numericalAnswers.length > 0) {
                        // For "how long" questions, look for reasonable time periods
                        if (questionText.includes('lifecycle') || questionText.includes('support')) {
                            const reasonableAnswer = numericalAnswers.find(answer => {
                                const text = (answer.title || answer.html || answer.text || '');
                                const numbers = text.match(/\d+/g);
                                if (numbers) {
                                    const num = parseInt(numbers[0]);
                                    return num >= 5 && num <= 15; // Reasonable support lifecycle
                                }
                                return false;
                            });
                            
                            if (reasonableAnswer) {
                                return {
                                    answer: reasonableAnswer,
                                    confidence: 0.7,
                                    reason: "Reasonable numerical value for lifecycle/support question"
                                };
                            }
                        }
                    }
                }
                
                return null;
            }
            
            // Consolidate multiple detection results
            consolidateDetectionResults(results, currentCorrect) {
                // Group by suggested answer
                const answerGroups = {};
                
                results.forEach(result => {
                    const answerId = result.suggestedAnswer.title || result.suggestedAnswer.html || result.suggestedAnswer.text;
                    if (!answerGroups[answerId]) {
                        answerGroups[answerId] = {
                            answer: result.suggestedAnswer,
                            methods: [],
                            totalConfidence: 0,
                            reasons: []
                        };
                    }
                    
                    answerGroups[answerId].methods.push(result.method);
                    answerGroups[answerId].totalConfidence += result.confidence;
                    answerGroups[answerId].reasons.push(result.reason);
                });
                
                // Find the answer with highest confidence
                let bestAnswer = null;
                let bestScore = 0;
                
                Object.values(answerGroups).forEach(group => {
                    const score = group.totalConfidence * group.methods.length; // Weight by number of methods
                    if (score > bestScore) {
                        bestScore = score;
                        bestAnswer = group;
                    }
                });
                
                if (bestAnswer && bestScore > 0.5) {
                    return {
                        currentCorrect: currentCorrect ? (currentCorrect.title || currentCorrect.html || currentCorrect.text) : 'None marked',
                        suggestedCorrect: bestAnswer.answer.title || bestAnswer.answer.html || bestAnswer.answer.text,
                        confidence: Math.min(1.0, bestScore),
                        methods: bestAnswer.methods,
                        reasons: bestAnswer.reasons,
                        detectionCount: bestAnswer.methods.length
                    };
                }
                
                return null;
            }
            
            // Get detailed debug analysis showing all detection methods
            getDebugAnalysis(question, questionText) {
                const answers = question.answers;
                if (!answers || answers.length === 0) return null;
                
                const allResults = [];
                
                // Run all detection methods individually
                const feedbackResult = this.analyzeAnswerFeedback(question);
                if (feedbackResult) {
                    allResults.push({
                        method: "Feedback Analysis",
                        suggestedAnswer: feedbackResult.answer,
                        confidence: feedbackResult.confidence,
                        reason: feedbackResult.reason
                    });
                }
                
                const specificityResult = this.analyzeAnswerSpecificity(answers, questionText);
                if (specificityResult) {
                    allResults.push({
                        method: "Content Specificity",
                        suggestedAnswer: specificityResult.answer,
                        confidence: specificityResult.confidence,
                        reason: specificityResult.reason
                    });
                }
                
                const keywordResult = this.analyzeKeywordPatterns(answers, questionText);
                if (keywordResult) {
                    allResults.push({
                        method: "Keyword Pattern",
                        suggestedAnswer: keywordResult.answer,
                        confidence: keywordResult.confidence,
                        reason: keywordResult.reason
                    });
                }
                
                const grammarResult = this.analyzeGrammaticalFit(answers, questionText);
                if (grammarResult) {
                    allResults.push({
                        method: "Grammar Analysis",
                        suggestedAnswer: grammarResult.answer,
                        confidence: grammarResult.confidence,
                        reason: grammarResult.reason
                    });
                }
                
                const factualResult = this.analyzeFactualPatterns(answers, questionText);
                if (factualResult) {
                    allResults.push({
                        method: "Factual Pattern",
                        suggestedAnswer: factualResult.answer,
                        confidence: factualResult.confidence,
                        reason: factualResult.reason
                    });
                }
                
                return { allResults };
            }

            // Legacy method for backward compatibility
            suggestCorrectAnswer(question, questionText) {
                const result = this.detectCorrectAnswer(question, questionText);
                if (result) {
                    return {
                        currentCorrect: result.currentCorrect,
                        suggestedCorrect: result.suggestedCorrect,
                        reason: `${result.methods.join(' + ')} (confidence: ${Math.round(result.confidence * 100)}%)`
                    };
                }
                return null;
            }

            // Quiz-level validation to detect systematic issues
            validateQuizPatterns(lesson) {
                const warnings = [];
                
                if (!lesson.items || !Array.isArray(lesson.items)) {
                    return warnings;
                }
                
                const questions = lesson.items.filter(item => item.answers && Array.isArray(item.answers));
                if (questions.length === 0) {
                    return warnings;
                }
                
                // Check for suspicious patterns across all questions
                let firstAnswerCorrectCount = 0;
                let lastAnswerCorrectCount = 0;
                let questionsWithMultipleCorrect = 0;
                let questionsWithNoCorrect = 0;
                
                questions.forEach(question => {
                    const correctAnswers = question.answers.filter(answer => 
                        answer.correct || (question.corrects && question.corrects.includes(answer.id))
                    );
                    
                    if (correctAnswers.length === 0) {
                        questionsWithNoCorrect++;
                    } else if (correctAnswers.length > 1 && question.type !== 'multipleResponse') {
                        questionsWithMultipleCorrect++;
                    }
                    
                    // Check if first or last answer is consistently correct
                    if (question.answers.length > 1) {
                        const firstCorrect = question.answers[0].correct || (question.corrects && question.corrects.includes(question.answers[0].id));
                        const lastCorrect = question.answers[question.answers.length - 1].correct || (question.corrects && question.corrects.includes(question.answers[question.answers.length - 1].id));
                        
                        if (firstCorrect && correctAnswers.length === 1) firstAnswerCorrectCount++;
                        if (lastCorrect && correctAnswers.length === 1) lastAnswerCorrectCount++;
                    }
                });
                
                // Flag suspicious patterns
                const totalQuestions = questions.length;
                
                if (firstAnswerCorrectCount > totalQuestions * 0.6) {
                    warnings.push(`üö® SYSTEMATIC ISSUE: ${firstAnswerCorrectCount}/${totalQuestions} questions have the first answer marked as correct. This may indicate an answer key mapping problem due to randomization.`);
                }
                
                if (lastAnswerCorrectCount > totalQuestions * 0.6) {
                    warnings.push(`üö® SYSTEMATIC ISSUE: ${lastAnswerCorrectCount}/${totalQuestions} questions have the last answer marked as correct. This may indicate an answer key mapping problem.`);
                }
                
                if (questionsWithMultipleCorrect > totalQuestions * 0.3) {
                    warnings.push(`üö® SYSTEMATIC ISSUE: ${questionsWithMultipleCorrect}/${totalQuestions} questions have multiple correct answers in what appear to be single-choice questions.`);
                }
                
                if (questionsWithNoCorrect > 0) {
                    warnings.push(`üö® SYSTEMATIC ISSUE: ${questionsWithNoCorrect}/${totalQuestions} questions have no correct answers marked.`);
                }
                
                return warnings;
            }

            parseQuizLesson(lesson) {
                let content = [];
                

                
                // Add simple validation warning if systematic issues detected
                const quizWarnings = this.validateQuizPatterns(lesson);
                if (quizWarnings.length > 0) {
                    content.push('‚ö†Ô∏è **NOTICE: This quiz may have answer key issues. Please review all questions and answers for accuracy before use.**');
                    content.push('');
                }
                
                // Add quiz description if available
                if (lesson.description) {
                    content.push(this.cleanHtmlText(lesson.description));
                }
                
                // Add quiz settings information
                if (lesson.settings) {
                    const settings = lesson.settings;
                    let settingsInfo = [];
                    
                    if (settings.passingScore) {
                        settingsInfo.push(`**Passing Score:** ${settings.passingScore}%`);
                    }
                    if (settings.retryCount) {
                        settingsInfo.push(`**Retry Attempts:** ${settings.retryCount}`);
                    }
                    if (settings.randomizeQuestionOrder) {
                        settingsInfo.push(`**Question Order:** Randomized`);
                    }
                    if (settings.shuffleAnswerChoices) {
                        settingsInfo.push(`**Answer Choices:** Shuffled`);
                    }
                    
                    if (settingsInfo.length > 0) {
                        content.push('### Quiz Settings');
                        content.push(settingsInfo.join('\n'));
                    }
                }
                
                // Process quiz questions
                if (lesson.items && Array.isArray(lesson.items)) {
                    content.push('### Questions\n');
                    
                    lesson.items.forEach((question, index) => {
                        const questionContent = this.parseQuizQuestion(question, index + 1);
                        if (questionContent) {
                            content.push(questionContent);
                        }
                    });
                }
                
                return content.join('\n\n');
            }
            
            parseQuizQuestion(question, questionNumber) {
                let result = [];
                
                // Question title/text
                if (question.title) {
                    result.push(`#### Question ${questionNumber}`);
                    result.push(this.cleanHtmlText(question.title));
                }
                
                // Question type
                if (question.type) {
                    const typeDisplay = question.type.replace(/_/g, ' ').toLowerCase()
                        .replace(/\b\w/g, l => l.toUpperCase());
                    result.push(`**Type:** ${typeDisplay}`);
                }
                
                // Answer choices
                if (question.answers && Array.isArray(question.answers)) {
                    result.push('\n**Answer Options:**');
                    
                    // Validate answer correctness before processing
                    const correctAnswers = question.answers.filter(answer => 
                        answer.correct || (question.corrects && question.corrects.includes(answer.id))
                    );
                    
                    // Simple validation - just log to console, don't add to output
                    if (correctAnswers.length === 0) {
                        console.warn(`‚ö†Ô∏è Question "${question.title || 'Untitled'}" has no correct answers marked`);
                    } else if (correctAnswers.length > 1 && question.type !== 'multipleResponse') {
                        console.warn(`‚ö†Ô∏è Question "${question.title || 'Untitled'}" has ${correctAnswers.length} correct answers but appears to be single-choice`);
                    }
                    

                    
                    question.answers.forEach((answer, index) => {
                        const letter = String.fromCharCode(65 + index); // A, B, C, D...
                        const answerText = this.cleanHtmlText(answer.title || answer.html || answer.text || '');
                        const isCorrect = answer.correct || (question.corrects && question.corrects.includes(answer.id));
                        const checkmark = isCorrect ? ' ‚úÖ' : '';
                        
                        result.push(`${letter}. ${answerText}${checkmark}`);
                    });
                    

                }
                
                // Feedback
                if (question.feedback) {
                    result.push(`\n**Feedback:** ${this.cleanHtmlText(question.feedback)}`);
                }
                
                return result.join('\n');
            }
            
            async parseRiseLessonItems(blocks, lessonTitle = '') {
                let content = [];
                
                for (const block of blocks) {
                    if (!block || !block.type) continue;
                    
                    switch (block.type) {
                        case 'text':
                            if (block.items && Array.isArray(block.items)) {
                                for (const item of block.items) {
                                    if (item.heading) {
                                        const cleanHeading = this.cleanHtmlText(item.heading);
                                        if (cleanHeading) content.push(`### ${cleanHeading}`);
                                    }
                                    if (item.paragraph) {
                                        const cleanText = this.cleanHtmlText(item.paragraph);
                                        if (cleanText) content.push(cleanText);
                                    }
                                }
                            }
                            break;
                            
                        case 'knowledgeCheck':
                            if (block.items && Array.isArray(block.items)) {
                                for (const item of block.items) {
                                    content.push(this.parseKnowledgeCheckItem(item));
                                }
                            }
                            break;
                            
                        case 'list':
                            if (block.items && Array.isArray(block.items)) {
                                for (const item of block.items) {
                                    if (item.paragraph) {
                                        const cleanText = this.cleanHtmlText(item.paragraph);
                                        if (cleanText) content.push(`‚Ä¢ ${cleanText}`);
                                    }
                                }
                            }
                            break;
                            
                        case 'interactive':
                            content.push(this.parseInteractive(block));
                            break;
                            
                        case 'image':
                            if (block.items && Array.isArray(block.items)) {
                                for (const item of block.items) {
                                    if (item.media && item.media.image) {
                                        let imageContent = [];
                                        
                                        const title = item.media.image.title || item.title || 'Image Content';
                                        imageContent.push(`### üñºÔ∏è Image: ${this.cleanHtmlText(title)}`);
                                        
                                        // Add paragraph content if available
                                        if (item.paragraph) {
                                            const cleanText = this.cleanHtmlText(item.paragraph);
                                            if (cleanText) {
                                                imageContent.push(`**Description:** ${cleanText}`);
                                            }
                                        }
                                        
                                        if (item.media.image.alt) {
                                            imageContent.push(`**Alt Text:** ${this.cleanHtmlText(item.media.image.alt)}`);
                                        }
                                        
                                        if (item.media.image.description) {
                                            imageContent.push(`**Description:** ${this.cleanHtmlText(item.media.image.description)}`);
                                        }
                                        
                                        if (item.media.image.caption) {
                                            imageContent.push(`**Caption:** ${this.cleanHtmlText(item.media.image.caption)}`);
                                        }
                                        
                                        // Handle different image source field names
                                        const imageSrc = item.media.image.src || 
                                                       (item.media.image.crushedKey ? `scormcontent/assets/${item.media.image.crushedKey}` : null) ||
                                                       (item.media.image.key ? `scormcontent/assets/${item.media.image.key}` : null) ||
                                                       item.media.image.originalUrl;
                                        
                                        if (imageSrc) {
                                            const filename = imageSrc.split('/').pop() || item.media.image.originalUrl || 'unknown-image';
                                            const fullPath = imageSrc;
                                            
                                            // Add enhanced file information directly in content
                                            imageContent.push(`**üìÅ File Information:**`);
                                            imageContent.push(`- **Filename:** ${filename}`);
                                            imageContent.push(`- **Location:** ${fullPath}`);
                                            
                                            // Try to get image metadata from ZIP
                                            if (this.currentZip && this.currentZip.files[fullPath]) {
                                                const imageFile = this.currentZip.files[fullPath];
                                                const sizeKB = (imageFile._data.uncompressedSize / 1024).toFixed(1);
                                                imageContent.push(`- **File Size:** ${sizeKB} KB`);
                                                
                                                // Extract image dimensions if possible
                                                const extension = filename.split('.').pop()?.toLowerCase();
                                                imageContent.push(`- **File Type:** ${extension?.toUpperCase() || 'Unknown'}`);
                                            } else {
                                                // If not in ZIP, still show what we can
                                                const extension = filename.split('.').pop()?.toLowerCase();
                                                imageContent.push(`- **File Type:** ${extension?.toUpperCase() || 'Unknown'}`);
                                            }
                                            
                                            // Check dimensions if available in metadata (multiple possible locations)
                                            if (item.media.image.width && item.media.image.height) {
                                                imageContent.push(`- **Dimensions:** ${item.media.image.width}x${item.media.image.height} pixels`);
                                            } else if (item.media.image.dimensions && item.media.image.dimensions.originalWidth && item.media.image.dimensions.originalHeight) {
                                                imageContent.push(`- **Dimensions:** ${item.media.image.dimensions.originalWidth}x${item.media.image.dimensions.originalHeight} pixels`);
                                            }
                                            
                                            // Add access instructions with specific path
                                            imageContent.push(`- **Access:** Open SCORM zip ‚Üí ${fullPath}`);
                                        }
                                        
                                        if (imageContent.length > 0) {
                                            content.push(imageContent.join('\n'));
                                        }
                                    }
                                }
                            }
                            break;
                            
                        case 'multimedia':
                            if (block.items && Array.isArray(block.items)) {
                                for (const item of block.items) {
                                    if (item.media) {
                                        let mediaContent = [];
                                        
                                        // Debug: log media structure
                                        console.log('Media item structure:', JSON.stringify(item, null, 2));
                                        
                                        // Check if this is a transcript attachment item
                                        if (item.media?.attachment && 
                                            (item.media.attachment.filename?.toLowerCase().includes('transcript') || 
                                             item.media.attachment.originalUrl?.toLowerCase().includes('transcript'))) {
                                            
                                            console.log('üìÑ Found transcript attachment item:', item.media.attachment.originalUrl);
                                            
                                            // Create attachment object and extract transcript directly
                                            const attachment = {
                                                href: item.media.attachment.key || item.media.attachment.originalUrl,
                                                download: item.media.attachment.filename,
                                                title: item.media.attachment.originalUrl || item.media.attachment.filename,
                                                size: item.media.attachment.size,
                                                mimeType: item.media.attachment.mimeType
                                            };
                                            
                                            await this.extractTranscriptFromAttachment(attachment, mediaContent);
                                        }
                                        // Check for video content
                                        if (item.media.embed) {
                                            const title = item.media.embed.title || item.title || 'Video Content';
                                            mediaContent.push(`### üìπ Video: ${this.cleanHtmlText(title)}`);
                                            
                                            // Extract more metadata
                                            if (item.media.embed.description) {
                                                mediaContent.push(`**Description:** ${this.cleanHtmlText(item.media.embed.description)}`);
                                            }
                                            
                                            if (item.media.embed.duration) {
                                                mediaContent.push(`**Duration:** ${item.media.embed.duration}`);
                                            }
                                            
                                            if (item.media.embed.src) {
                                                // Extract iframe title if available
                                                const titleMatch = item.media.embed.src.match(/title="([^"]+)"/);
                                                if (titleMatch) {
                                                    mediaContent.push(`**Video Title:** ${titleMatch[1]}`);
                                                }
                                                
                                                // Extract video ID or URL info
                                                const youtubeMatch = item.media.embed.src.match(/youtube\.com\/embed\/([^?"]+)/);
                                                const vimeoMatch = item.media.embed.src.match(/vimeo\.com\/video\/([^?"]+)/);
                                                
                                                if (youtubeMatch) {
                                                    mediaContent.push(`**Video ID:** YouTube - ${youtubeMatch[1]}`);
                                                } else if (vimeoMatch) {
                                                    mediaContent.push(`**Video ID:** Vimeo - ${vimeoMatch[1]}`);
                                                }
                                            }
                                            
                                            // Check for captions/transcript
                                            if (item.media.embed.captions || item.captions) {
                                                mediaContent.push(`**Captions:** Available`);
                                            }
                                            
                                            if (item.media.embed.transcript || item.transcript) {
                                                const transcript = item.media.embed.transcript || item.transcript;
                                                mediaContent.push(`**Transcript:** ${this.cleanHtmlText(transcript)}`);
                                            }
                                            
                                            // Check for matching transcript attachment
                                            const videoTitle = item.media.embed.title || item.title || 'video';
                                            const matchingTranscript = this.findMatchingTranscript(videoTitle, lessonTitle);
                                            if (matchingTranscript) {
                                                await this.extractTranscriptFromAttachment(matchingTranscript, mediaContent);
                                            } else {
                                                // Fallback to the old method if no matching transcript found
                                            await this.checkForTranscriptPdf(mediaContent, videoTitle, lessonTitle, `video_${block.type || 'multimedia'}`);
                                            }
                                        }
                                        // Check for audio content
                                        else if (item.media.audio) {
                                            const title = item.media.audio.title || item.title || 'Audio Content';
                                            mediaContent.push(`### üéµ Audio: ${this.cleanHtmlText(title)}`);
                                            
                                            if (item.media.audio.description) {
                                                mediaContent.push(`**Description:** ${this.cleanHtmlText(item.media.audio.description)}`);
                                            }
                                            
                                            if (item.media.audio.duration) {
                                                mediaContent.push(`**Duration:** ${item.media.audio.duration}`);
                                            }
                                            
                                            if (item.media.audio.src) {
                                                const filename = item.media.audio.src.split('/').pop();
                                                mediaContent.push(`**File:** ${filename}`);
                                            }
                                            
                                            if (item.media.audio.transcript || item.transcript) {
                                                const transcript = item.media.audio.transcript || item.transcript;
                                                mediaContent.push(`**Transcript:** ${this.cleanHtmlText(transcript)}`);
                                            }
                                            
                                            // Check for transcript attachments in the media item
                                            const transcriptAttachments = this.findTranscriptAttachments(item);
                                            if (transcriptAttachments.length > 0) {
                                                for (const attachment of transcriptAttachments) {
                                                    await this.extractTranscriptFromAttachment(attachment, mediaContent);
                                                }
                                            } else {
                                                // Fallback to the old method if no attachments found
                                            const audioTitle = item.media.audio.title || item.title || 'audio';
                                            await this.checkForTranscriptPdf(mediaContent, audioTitle, lessonTitle, `audio_${block.type || 'multimedia'}`);
                                            }
                                        }
                                        // Check for image content
                                        else if (item.media.image) {
                                            const title = item.media.image.title || item.title || 'Image Content';
                                            mediaContent.push(`### üñºÔ∏è Image: ${this.cleanHtmlText(title)}`);
                                            
                                            if (item.media.image.alt) {
                                                mediaContent.push(`**Alt Text:** ${this.cleanHtmlText(item.media.image.alt)}`);
                                            }
                                            
                                            if (item.media.image.description) {
                                                mediaContent.push(`**Description:** ${this.cleanHtmlText(item.media.image.description)}`);
                                            }
                                            
                                            if (item.media.image.caption) {
                                                mediaContent.push(`**Caption:** ${this.cleanHtmlText(item.media.image.caption)}`);
                                            }
                                            
                                            // Handle different image source field names
                                            const imageSrc = item.media.image.src || 
                                                           (item.media.image.crushedKey ? `scormcontent/assets/${item.media.image.crushedKey}` : null) ||
                                                           (item.media.image.key ? `scormcontent/assets/${item.media.image.key}` : null) ||
                                                           item.media.image.originalUrl;
                                            
                                            if (imageSrc) {
                                                const filename = imageSrc.split('/').pop() || item.media.image.originalUrl || 'unknown-image';
                                                const fullPath = imageSrc;
                                                
                                                // Add enhanced file information directly in content
                                                mediaContent.push(`**üìÅ File Information:**`);
                                                mediaContent.push(`- **Filename:** ${filename}`);
                                                mediaContent.push(`- **Location:** ${fullPath}`);
                                                
                                                // Try to get image metadata from ZIP
                                                if (this.currentZip && this.currentZip.files[fullPath]) {
                                                    const imageFile = this.currentZip.files[fullPath];
                                                    const sizeKB = (imageFile._data.uncompressedSize / 1024).toFixed(1);
                                                    mediaContent.push(`- **File Size:** ${sizeKB} KB`);
                                                    
                                                    // Extract image dimensions if possible
                                                    const extension = filename.split('.').pop()?.toLowerCase();
                                                    mediaContent.push(`- **File Type:** ${extension?.toUpperCase() || 'Unknown'}`);
                                                } else {
                                                    // If not in ZIP, still show what we can
                                                    const extension = filename.split('.').pop()?.toLowerCase();
                                                    mediaContent.push(`- **File Type:** ${extension?.toUpperCase() || 'Unknown'}`);
                                            }
                                            
                                                // Check dimensions if available in metadata (multiple possible locations)
                                            if (item.media.image.width && item.media.image.height) {
                                                    mediaContent.push(`- **Dimensions:** ${item.media.image.width}x${item.media.image.height} pixels`);
                                                } else if (item.media.image.dimensions && item.media.image.dimensions.originalWidth && item.media.image.dimensions.originalHeight) {
                                                    mediaContent.push(`- **Dimensions:** ${item.media.image.dimensions.originalWidth}x${item.media.image.dimensions.originalHeight} pixels`);
                                                }
                                                
                                                // Add access instructions with specific path
                                                mediaContent.push(`- **Access:** Open SCORM zip ‚Üí ${fullPath}`);
                                            }
                                        }
                                        // Generic media - extract any available metadata
                                        else {
                                            const title = item.title || 'Media Content';
                                            mediaContent.push(`### üì± Media: ${this.cleanHtmlText(title)}`);
                                            
                                            // Try to extract any available metadata
                                            if (item.description) {
                                                mediaContent.push(`**Description:** ${this.cleanHtmlText(item.description)}`);
                                            }
                                            
                                            if (item.filename) {
                                                mediaContent.push(`**File:** ${item.filename}`);
                                            }
                                            
                                            if (item.type) {
                                                mediaContent.push(`**Type:** ${item.type}`);
                                            }
                                        }
                                        
                                        // Check for general item-level metadata
                                        if (item.instructions) {
                                            mediaContent.push(`**Instructions:** ${this.cleanHtmlText(item.instructions)}`);
                                        }
                                        
                                        if (item.notes) {
                                            mediaContent.push(`**Notes:** ${this.cleanHtmlText(item.notes)}`);
                                        }
                                        
                                        if (mediaContent.length > 0) {
                                            content.push(mediaContent.join('\n'));
                                        }
                                    }
                                    
                                    // Also check for media at the item level (not nested in .media)
                                    else if (item.type && (item.type === 'video' || item.type === 'audio' || item.type === 'image')) {
                                        let mediaContent = [];
                                        const emoji = item.type === 'video' ? 'üìπ' : item.type === 'audio' ? 'üéµ' : 'üñºÔ∏è';
                                        const title = item.title || `${item.type.charAt(0).toUpperCase() + item.type.slice(1)} Content`;
                                        
                                        mediaContent.push(`### ${emoji} ${this.cleanHtmlText(title)}`);
                                        
                                        if (item.description) {
                                            mediaContent.push(`**Description:** ${this.cleanHtmlText(item.description)}`);
                                        }
                                        
                                        if (item.src || item.url) {
                                            const filename = (item.src || item.url).split('/').pop();
                                            mediaContent.push(`**File:** ${filename}`);
                                        }
                                        
                                        if (mediaContent.length > 0) {
                                            content.push(mediaContent.join('\n'));
                                        }
                                    }
                                }
                            }
                            break;
                            
                        case 'divider':
                            if (block.items && Array.isArray(block.items)) {
                                for (const item of block.items) {
                                    if (item.title) {
                                        // Clean up common divider titles
                                        let cleanTitle = item.title.trim();
                                        if (cleanTitle.toUpperCase() === 'CONTINUE') {
                                            content.push(`\n---\n\n`);
                                        } else {
                                            content.push(`\n---\n### ${cleanTitle}\n---\n`);
                                        }
                                    }
                                }
                            }
                            break;
                    }
                }
                
                // Filter out empty content and clean up spacing
                const cleanContent = content
                    .filter(item => item && item.trim())
                    .map(item => item.trim())
                    .join('\n\n')
                    // Remove excessive line breaks
                    .replace(/\n\n\n+/g, '\n\n')
                    // Clean up divider spacing
                    .replace(/\n\n---\n\n\n/g, '\n\n---\n\n')
                    .replace(/\n---\n\n\n/g, '\n\n---\n\n');
                
                return cleanContent;
            }
            
            parseKnowledgeCheckItem(item) {
                let result = [];
                
                if (item.title) {
                    result.push(`### üß† Knowledge Check: ${this.cleanHtmlText(item.title)}`);
                }
                
                if (item.answers && Array.isArray(item.answers)) {
                    result.push('\n**Answer Options:**');
                    
                    // Simple validation - just log to console, don't add to output
                    const correctAnswers = item.answers.filter(answer => answer.correct);
                    if (correctAnswers.length === 0) {
                        console.warn(`‚ö†Ô∏è Knowledge check "${item.title || 'Untitled'}" has no correct answers marked`);
                    } else if (correctAnswers.length > 1) {
                        console.warn(`‚ö†Ô∏è Knowledge check "${item.title || 'Untitled'}" has ${correctAnswers.length} correct answers - verify if multiple choice`);
                    }
                    
                    item.answers.forEach((answer, index) => {
                        const letter = String.fromCharCode(65 + index);
                        const answerText = this.cleanHtmlText(answer.title || answer.html || answer.text || '');
                        const checkmark = answer.correct ? ' ‚úÖ' : '';
                        result.push(`${letter}. ${answerText}${checkmark}`);
                    });
                }
                
                if (item.feedbackCorrect) {
                    result.push(`\n**‚úÖ Correct Feedback:** ${this.cleanHtmlText(item.feedbackCorrect)}`);
                }
                
                if (item.feedbackIncorrect) {
                    result.push(`**‚ùå Incorrect Feedback:** ${this.cleanHtmlText(item.feedbackIncorrect)}`);
                }
                
                return result.join('\n');
            }
            
            parseInteractive(block) {
                if (!block.variant && !block.family) return '';
                
                const variant = block.variant || block.family;
                
                // Debug: log the variant to see what types we're encountering
                console.log('Interactive variant found:', variant, 'Block:', block);
                
                switch (variant) {
                    case 'accordion':
                        return this.parseAccordion(block);
                    case 'process':
                        return this.parseProcess(block);
                    case 'storyline':
                    case 'scenario':  // Add scenario as a storyline type
                        return this.parseStoryline(block);
                    case 'buttons':
                    case 'button':
                        return this.parseButtons(block);
                    case 'tabs':
                        return this.parseTabs(block);
                    case 'interactive-fullscreen':
                        return this.parseInteractiveFullscreen(block);
                    case 'labeledgraphic':
                        return this.parseLabeledGraphic(block);
                    case 'timeline':
                        return this.parseTimeline(block);
                    case 'flashcard':
                        return this.parseFlashcard(block);
                    case 'sorting':
                        return this.parseSorting(block);
                    case 'button stack':
                        return this.parseButtonStack(block);
                    default:
                        // Log unknown variants to help identify new types
                        console.log('Unknown interactive variant:', variant, 'Full block:', JSON.stringify(block, null, 2));
                        return `### üîß Interactive Element: ${variant}\n${block.title || 'Interactive Content'}`;
                }
            }
            
            parseAccordion(block) {
                let result = [`### ${block.title || 'Interactive Accordion'}`];
                
                // Debug: log the accordion structure
                console.log('Accordion block structure:', JSON.stringify(block, null, 2));
                
                if (block.items && Array.isArray(block.items)) {
                    block.items.forEach(item => {
                        if (item.title) {
                            result.push(`\n**${this.cleanHtmlText(item.title)}**`);
                        }
                        
                        // Try multiple possible content fields
                        const content = item.html || item.content || item.description || item.text || item.body;
                        if (content) {
                            result.push(this.cleanHtmlTextWithFormatting(content));
                        }
                        
                        // Check if there are nested items
                        if (item.items && Array.isArray(item.items)) {
                            item.items.forEach(subItem => {
                                if (subItem.html || subItem.content || subItem.text) {
                                    result.push(this.cleanHtmlTextWithFormatting(subItem.html || subItem.content || subItem.text));
                                }
                            });
                        }
                        
                        // Check for data property (common in Rise content)
                        if (item.data && typeof item.data === 'object') {
                            const dataContent = item.data.html || item.data.content || item.data.text || item.data.description;
                            if (dataContent) {
                                result.push(this.cleanHtmlTextWithFormatting(dataContent));
                            }
                        }
                    });
                }
                
                // Fallback: check if block has direct content
                if (!block.items && (block.html || block.content || block.text)) {
                    result.push(this.cleanHtmlTextWithFormatting(block.html || block.content || block.text));
                }
                
                return result.join('\n');
            }
            
            parseProcess(block) {
                let result = [`### üìã ${block.title || 'Interactive Process'}`];
                
                if (block.items && Array.isArray(block.items)) {
                    block.items.forEach((step, index) => {
                        if (step.type === 'step') {
                            result.push(`\n**Step ${index + 1}:** ${step.title || 'Process Step'}`);
                            if (step.description) {
                                result.push(this.cleanHtmlText(step.description));
                            }
                        } else if (step.type === 'intro') {
                            result.push(`\n**Introduction:** ${step.title || ''}`);
                            if (step.description) {
                                result.push(this.cleanHtmlText(step.description));
                            }
                        } else if (step.type === 'summary') {
                            result.push(`\n**Summary:** ${step.title || ''}`);
                            if (step.description) {
                                result.push(this.cleanHtmlText(step.description));
                            }
                        }
                    });
                }
                
                // Fallback for older structure
                if (block.steps && Array.isArray(block.steps)) {
                    block.steps.forEach((step, index) => {
                        result.push(`\n**Step ${index + 1}:** ${step.title || 'Process Step'}`);
                        if (step.html) {
                            result.push(this.cleanHtmlText(step.html));
                        }
                    });
                }
                
                return result.join('\n');
            }
            
            parseButtons(block) {
                let result = [`### üîó Interactive Buttons`];
                
                if (block.items && Array.isArray(block.items)) {
                    block.items.forEach(button => {
                        if (button.label) {
                            result.push(`\n**${button.label}**`);
                        }
                        if (button.description) {
                            result.push(this.cleanHtmlText(button.description));
                        }
                        if (button.destination) {
                            result.push(`*Link: ${button.destination}*`);
                        }
                    });
                }
                
                return result.join('\n');
            }
            
            parseTabs(block) {
                let result = [`### üìë Interactive Tabs`];
                
                if (block.items && Array.isArray(block.items)) {
                    block.items.forEach((tab, index) => {
                        result.push(`\n**Tab ${index + 1}:** ${tab.title || 'Tab Content'}`);
                        if (tab.description) {
                            result.push(this.cleanHtmlText(tab.description));
                        }
                        if (tab.content) {
                            result.push(this.cleanHtmlText(tab.content));
                        }
                    });
                }
                
                return result.join('\n');
            }
            
            parseInteractiveFullscreen(block) {
                let result = [`### üñ•Ô∏è ${block.title || 'Interactive Fullscreen Content'}`];
                
                if (block.items && Array.isArray(block.items)) {
                    block.items.forEach(item => {
                        if (item.title) {
                            result.push(`\n**${item.title}**`);
                        }
                        if (item.description) {
                            result.push(this.cleanHtmlText(item.description));
                        }
                    });
                }
                
                return result.join('\n');
            }
            
            parseStoryline(block) {
                const variant = block.variant || block.family;
                const isScenario = variant === 'scenario';
                const title = block.title || (isScenario ? 'Interactive Scenario' : 'Interactive Content');
                const emoji = isScenario ? 'üé≠' : 'üéÆ';
                const type = isScenario ? 'Scenario' : 'Storyline Activity';
                
                let result = [`### ${emoji} ${type}: ${title}`];
                
                // Debug: log the storyline structure
                console.log('Storyline block structure:', JSON.stringify(block, null, 2));
                
                // Extract basic information
                if (block.description) {
                    result.push(`\n**Description:** ${this.cleanHtmlText(block.description)}`);
                }
                
                // Check for embedded content or iframe
                if (block.embed || block.iframe) {
                    const embedData = block.embed || block.iframe;
                    
                    if (embedData.title) {
                        result.push(`**Activity Title:** ${this.cleanHtmlText(embedData.title)}`);
                    }
                    
                    if (embedData.description) {
                        result.push(`**Activity Description:** ${this.cleanHtmlText(embedData.description)}`);
                    }
                    
                    if (embedData.src) {
                        // Extract filename from src
                        const filename = embedData.src.split('/').pop();
                        result.push(`**Storyline File:** ${filename}`);
                        
                        // Try to extract any additional info from the src path
                        if (embedData.src.includes('story.html') || embedData.src.includes('index.html')) {
                            result.push(`**Type:** Interactive Storyline Module`);
                        }
                    }
                    
                    if (embedData.width && embedData.height) {
                        result.push(`**Dimensions:** ${embedData.width}x${embedData.height}`);
                    }
                }
                
                // Check for storyline-specific content
                if (block.content) {
                    result.push(`\n**Content:**`);
                    result.push(this.cleanHtmlText(block.content));
                }
                
                // Check for scenarios or slides
                if (block.slides && Array.isArray(block.slides)) {
                    result.push(`\n**Slides/Scenarios:**`);
                    block.slides.forEach((slide, index) => {
                        result.push(`\n**Slide ${index + 1}:**`);
                        if (slide.title) {
                            result.push(`*${this.cleanHtmlText(slide.title)}*`);
                        }
                        if (slide.content || slide.text) {
                            result.push(this.cleanHtmlText(slide.content || slide.text));
                        }
                        if (slide.notes) {
                            result.push(`**Notes:** ${this.cleanHtmlText(slide.notes)}`);
                        }
                    });
                }
                
                // Check for interactions or questions
                if (block.interactions && Array.isArray(block.interactions)) {
                    result.push(`\n**Interactions:**`);
                    block.interactions.forEach((interaction, index) => {
                        result.push(`\n**Interaction ${index + 1}:**`);
                        if (interaction.question) {
                            result.push(`*Question:* ${this.cleanHtmlText(interaction.question)}`);
                        }
                        if (interaction.type) {
                            result.push(`*Type:* ${interaction.type}`);
                        }
                        if (interaction.feedback) {
                            result.push(`*Feedback:* ${this.cleanHtmlText(interaction.feedback)}`);
                        }
                    });
                }
                
                // Check for variables or data
                if (block.variables && Array.isArray(block.variables)) {
                    result.push(`\n**Variables/Data:**`);
                    block.variables.forEach(variable => {
                        if (variable.name && variable.value) {
                            result.push(`- ${variable.name}: ${variable.value}`);
                        }
                    });
                }
                
                // Check for learning objectives
                if (block.objectives && Array.isArray(block.objectives)) {
                    result.push(`\n**Learning Objectives:**`);
                    block.objectives.forEach((objective, index) => {
                        result.push(`${index + 1}. ${this.cleanHtmlText(objective)}`);
                    });
                }
                
                // Check for items array (common structure) - Enhanced for scenarios
                if (block.items && Array.isArray(block.items)) {
                    block.items.forEach((item, index) => {
                        if (item.title) {
                            result.push(`\n**${item.title}**`);
                        }
                        
                        // Extract slides content (main scenario content)
                        if (item.slides && Array.isArray(item.slides)) {
                            result.push(`\n**Scenario Dialogue:**`);
                            
                            item.slides.forEach((slide, slideIndex) => {
                                if (slide.title) {
                                    result.push(`\n*${slideIndex + 1}. ${this.cleanHtmlText(slide.title)}*`);
                                }
                                
                                if (slide.description) {
                                    result.push(`${this.cleanHtmlText(slide.description)}`);
                                }
                                
                                // Handle responses/dialogue options
                                if (slide.responses && Array.isArray(slide.responses)) {
                                    slide.responses.forEach(response => {
                                        if (response.description) {
                                            result.push(`**Response:** ${this.cleanHtmlText(response.description)}`);
                                        }
                                    });
                                }
                                
                                // Add separator between dialogue exchanges
                                if (slideIndex < item.slides.length - 1) {
                                    result.push('');
                                }
                            });
                        }
                        
                        // Extract character information
                        if (item.character) {
                            result.push(`\n**Character:** ${item.character.name || 'Speaker'}`);
                        }
                        
                        // Extract text content from various possible fields
                        const content = item.content || item.text || item.description || item.html;
                        if (content) {
                            result.push(this.cleanHtmlText(content));
                        }
                        
                        // Check for nested items or steps
                        if (item.items && Array.isArray(item.items)) {
                            item.items.forEach((subItem, subIndex) => {
                                if (subItem.text || subItem.content) {
                                    result.push(`  - ${this.cleanHtmlText(subItem.text || subItem.content)}`);
                                }
                            });
                        }
                        
                        // Check for media within storyline
                        if (item.media) {
                            if (item.media.image && item.media.image.alt) {
                                result.push(`  *Image:* ${item.media.image.alt}`);
                            }
                            if (item.media.video && item.media.video.title) {
                                result.push(`  *Video:* ${item.media.video.title}`);
                            }
                            if (item.media.audio && item.media.audio.title) {
                                result.push(`  *Audio:* ${item.media.audio.title}`);
                            }
                            
                            // Handle Storyline media specifically
                            if (item.media.storyline) {
                                const storyline = item.media.storyline;
                                result.push(`\n**Storyline Module:**`);
                                if (storyline.title) {
                                    result.push(`**Title:** ${storyline.title}`);
                                }
                                if (storyline.src) {
                                    result.push(`**File:** ${storyline.src}`);
                                }
                                if (storyline.meta && storyline.meta.scenes) {
                                    result.push(`**Scenes:** ${storyline.meta.scenes.length}`);
                                    storyline.meta.scenes.forEach((scene, sceneIndex) => {
                                        if (scene.title) {
                                            result.push(`  ${sceneIndex + 1}. ${scene.title}`);
                                        }
                                    });
                                }
                                if (storyline.meta && storyline.meta.slides) {
                                    result.push(`**Slides:** ${storyline.meta.slides.length} slides`);
                                }
                            }
                        }
                    });
                }
                
                // Check for data property (common in Rise content)
                if (block.data && typeof block.data === 'object') {
                    const dataContent = block.data.content || block.data.text || block.data.html;
                    if (dataContent) {
                        result.push(`\n**Activity Data:**`);
                        result.push(this.cleanHtmlText(dataContent));
                    }
                    
                    // Check for storyline-specific data
                    if (block.data.storyline) {
                        const storylineData = block.data.storyline;
                        if (storylineData.title) {
                            result.push(`**Storyline Title:** ${storylineData.title}`);
                        }
                        if (storylineData.description) {
                            result.push(`**Storyline Description:** ${this.cleanHtmlText(storylineData.description)}`);
                        }
                    }
                }
                
                // Add instructions if available
                if (block.instructions) {
                    result.push(`\n**Instructions:**`);
                    result.push(this.cleanHtmlText(block.instructions));
                }
                
                // Add completion criteria if available
                if (block.completion) {
                    result.push(`\n**Completion Criteria:**`);
                    result.push(this.cleanHtmlText(block.completion));
                }
                
                return result.join('\n');
            }
            
            parseLabeledGraphic(block) {
                let result = [`### üñºÔ∏è Interactive Graphic: ${block.title || 'Labeled Graphic'}`];
                
                // Debug: log the labeled graphic structure
                console.log('Labeled graphic block structure:', JSON.stringify(block, null, 2));
                
                // Extract main image information
                if (block.media && block.media.image) {
                    const image = block.media.image;
                    result.push(`\n**Main Image:** ${image.originalUrl || 'Image'}`);
                    if (image.dimensions) {
                        result.push(`**Dimensions:** ${image.dimensions.originalWidth}x${image.dimensions.originalHeight}`);
                    }
                }
                
                // Extract hotspots/labels
                if (block.items && Array.isArray(block.items)) {
                    result.push(`\n**Interactive Hotspots:**`);
                    
                    block.items.forEach((item, index) => {
                        if (item.title) {
                            result.push(`\n**${index + 1}. ${this.cleanHtmlText(item.title)}**`);
                        }
                        
                        // Position information
                        if (item.x && item.y) {
                            result.push(`*Position: ${Math.round(item.x)}%, ${Math.round(item.y)}%*`);
                        }
                        
                        // Description/content
                        if (item.description) {
                            result.push(this.cleanHtmlText(item.description));
                        }
                        
                        // Media within hotspot
                        if (item.media) {
                            if (item.media.image && item.media.image.originalUrl) {
                                result.push(`*Image: ${item.media.image.originalUrl}*`);
                            }
                            if (item.media.tmp && item.media.tmp.image && item.media.tmp.image.originalUrl) {
                                result.push(`*Image: ${item.media.tmp.image.originalUrl}*`);
                            }
                        }
                        
                        // Add spacing between hotspots
                        if (index < block.items.length - 1) {
                            result.push('');
                        }
                    });
                }
                
                // Settings information
                if (block.settings) {
                    if (block.settings.zoomOnClick) {
                        result.push(`\n**Feature:** Click to zoom enabled`);
                    }
                    if (block.settings.markerColor) {
                        result.push(`**Marker Color:** ${block.settings.markerColor}`);
                    }
                }
                
                return result.join('\n');
            }
            
            parseTimeline(block) {
                let result = [`### üìÖ Timeline: ${block.title || 'Interactive Timeline'}`];
                
                // Debug: log the timeline structure
                console.log('Timeline block structure:', JSON.stringify(block, null, 2));
                
                // Extract timeline items
                if (block.items && Array.isArray(block.items)) {
                    result.push(`\n**Timeline Events:**`);
                    
                    block.items.forEach((item, index) => {
                        // Date/step information
                        if (item.date) {
                            result.push(`\n**${item.date}**`);
                        } else {
                            result.push(`\n**Step ${index + 1}**`);
                        }
                        
                        // Title
                        if (item.title) {
                            result.push(`*${this.cleanHtmlText(item.title)}*`);
                        }
                        
                        // Description/content
                        if (item.description) {
                            result.push(this.cleanHtmlText(item.description));
                        }
                        
                        // Media within timeline item
                        if (item.media) {
                            if (item.media.image) {
                                const image = item.media.image;
                                if (image.originalUrl) {
                                    result.push(`**Image:** ${image.originalUrl}`);
                                }
                                if (image.dimensions) {
                                    result.push(`*Size: ${image.dimensions.originalWidth}x${image.dimensions.originalHeight}*`);
                                }
                            }
                        }
                        
                        // Add spacing between timeline items
                        if (index < block.items.length - 1) {
                            result.push('\n---');
                        }
                    });
                }
                
                // Settings information
                if (block.settings) {
                    if (block.settings.zoomOnClick) {
                        result.push(`\n**Feature:** Click to zoom enabled`);
                    }
                }
                
                return result.join('\n');
            }
            
            parseFlashcard(block) {
                let result = [`### üÉè Flashcards: ${block.title || 'Interactive Flashcards'}`];
                console.log('Flashcard block structure:', JSON.stringify(block, null, 2));
                
                if (block.items && Array.isArray(block.items)) {
                    result.push(`\n**Flashcard Set (${block.items.length} cards):**`);
                    
                    block.items.forEach((card, index) => {
                        result.push(`\n**Card ${index + 1}:**`);
                        
                        // Front of card
                        if (card.front) {
                            result.push(`*Front:* ${this.cleanHtmlTextWithFormatting(card.front.description || '')}`);
                            if (card.front.media && card.front.media.image) {
                                const filename = card.front.media.image.originalUrl || card.front.media.image.src || 'image';
                                result.push(`[Image: ${filename}]`);
                            }
                        }
                        
                        // Back of card
                        if (card.back) {
                            result.push(`*Back:* ${this.cleanHtmlTextWithFormatting(card.back.description || '')}`);
                            if (card.back.media && card.back.media.image) {
                                const filename = card.back.media.image.originalUrl || card.back.media.image.src || 'image';
                                result.push(`[Image: ${filename}]`);
                            }
                        }
                        
                        if (index < block.items.length - 1) {
                            result.push('\n---');
                        }
                    });
                }
                
                return result.join('\n');
            }
            
            parseSorting(block) {
                let result = [`### üóÇÔ∏è Sorting Activity: ${block.title || 'Interactive Sorting'}`];
                console.log('Sorting block structure:', JSON.stringify(block, null, 2));
                
                // Show the categories/piles
                if (block.piles && Array.isArray(block.piles)) {
                    result.push(`\n**Categories:**`);
                    block.piles.forEach(pile => {
                        result.push(`‚Ä¢ ${pile.title}`);
                    });
                }
                
                // Show items to be sorted
                if (block.items && Array.isArray(block.items)) {
                    result.push(`\n**Items to Sort:**`);
                    
                    // Group items by pile for answer key
                    const itemsByPile = {};
                    block.items.forEach(item => {
                        if (!itemsByPile[item.pileId]) {
                            itemsByPile[item.pileId] = [];
                        }
                        itemsByPile[item.pileId].push(item.title);
                    });
                    
                    // Show correct categorization
                    if (block.piles) {
                        block.piles.forEach(pile => {
                            if (itemsByPile[pile.id]) {
                                result.push(`\n**${pile.title}:**`);
                                itemsByPile[pile.id].forEach(itemTitle => {
                                    result.push(`‚Ä¢ ${itemTitle}`);
                                });
                            }
                        });
                    }
                }
                
                return result.join('\n');
            }
            
            parseButtonStack(block) {
                let result = [`### üîó Resource Links: ${block.title || 'Interactive Buttons'}`];
                console.log('Button stack block structure:', JSON.stringify(block, null, 2));
                
                if (block.items && Array.isArray(block.items)) {
                    result.push(`\n**Available Resources:**`);
                    
                    block.items.forEach((button, index) => {
                        if (button.label) {
                            result.push(`\n**${button.label}**`);
                        }
                        
                        if (button.description) {
                            result.push(this.cleanHtmlTextWithFormatting(button.description));
                        }
                        
                        if (button.destination) {
                            result.push(`**Link:** ${button.destination}`);
                        }
                        
                        if (index < block.items.length - 1) {
                            result.push('\n---');
                        }
                    });
                }
                
                return result.join('\n');
            }
            
            cleanHtmlTextWithFormatting(htmlString) {
                if (!htmlString) return '';
                
                // Create a temporary element to parse HTML
                const temp = document.createElement('div');
                temp.innerHTML = htmlString;
                
                // Remove script, style, and other unwanted elements
                const unwantedElements = temp.querySelectorAll('script, style, header, footer, nav');
                unwantedElements.forEach(el => el.remove());
                
                // Handle images to prevent browser from trying to load them
                const images = temp.querySelectorAll('img');
                images.forEach(img => {
                    const src = img.getAttribute('src');
                    const alt = img.getAttribute('alt') || '';
                    
                    if (src) {
                        const filename = src.split('/').pop();
                        img.outerHTML = alt ? `[Image: ${alt} (${filename})]` : `[Image: ${filename}]`;
                    } else {
                        img.remove();
                    }
                });
                
                // Handle hyperlinks before getting text content
                const links = temp.querySelectorAll('a[href]');
                links.forEach(link => {
                    const href = link.getAttribute('href');
                    const linkText = link.textContent || link.innerText || '';
                    
                    if (!href || href.startsWith('#') || !linkText.trim()) {
                        return;
                    }
                    
                    if (linkText.trim() && href !== linkText.trim()) {
                        link.outerHTML = `${linkText} (${href})`;
                    } else if (linkText.trim()) {
                        link.outerHTML = `${linkText} (${href})`;
                    } else {
                        link.outerHTML = `(${href})`;
                    }
                });
                
                // Convert HTML lists to markdown format
                this.convertListsToMarkdown(temp);
                
                // Get text content and clean it up
                let text = temp.textContent || temp.innerText || '';
                
                // Clean up common formatting issues
                text = text.replace(/\s+/g, ' ').trim();
                text = text.replace(/(\d+)of(\d+)/g, '$1 of $2');
                
                // Apply character encoding cleanup (same as cleanHtmlText)
                text = this.cleanCharacterEncoding(text);
                
                // Remove filler text
                text = this.removeFillerText(text);
                
                return text;
            }
            
            convertListsToMarkdown(element) {
                // Convert unordered lists (ul) to markdown bullets
                const ulElements = element.querySelectorAll('ul');
                ulElements.forEach(ul => {
                    const listItems = ul.querySelectorAll('li');
                    let markdownList = '\n';
                    
                    listItems.forEach(li => {
                        const depth = this.getListDepth(li);
                        const indent = '  '.repeat(depth); // 2 spaces per level
                        const bullet = depth === 0 ? '‚Ä¢' : '‚ó¶'; // Different bullets for sub-levels
                        const text = li.textContent?.trim() || '';
                        if (text) {
                            markdownList += `${indent}${bullet} ${text}\n`;
                        }
                    });
                    
                    ul.outerHTML = markdownList;
                });
                
                // Convert ordered lists (ol) to markdown numbers
                const olElements = element.querySelectorAll('ol');
                olElements.forEach(ol => {
                    const listItems = ol.querySelectorAll('li');
                    let markdownList = '\n';
                    
                    listItems.forEach((li, index) => {
                        const depth = this.getListDepth(li);
                        const indent = '  '.repeat(depth);
                        const number = index + 1;
                        const text = li.textContent?.trim() || '';
                        if (text) {
                            markdownList += `${indent}${number}. ${text}\n`;
                        }
                    });
                    
                    ol.outerHTML = markdownList;
                });
            }
            
            getListDepth(listItem) {
                let depth = 0;
                let parent = listItem.parentElement;
                
                while (parent && parent !== document.body) {
                    if (parent.tagName === 'UL' || parent.tagName === 'OL') {
                        depth++;
                    }
                    parent = parent.parentElement;
                }
                
                return Math.max(0, depth - 1); // Subtract 1 because we start counting from the immediate parent
            }
            
            cleanCharacterEncoding(text) {
                // Clean up special characters and encoding issues
                text = text.replace(/√¢‚Ç¨‚Ñ¢/g, "'");  // Right single quotation mark
                text = text.replace(/√¢‚Ç¨≈ì/g, '"');  // Left double quotation mark  
                text = text.replace(/√¢‚Ç¨/g, '"');   // Right double quotation mark
                text = text.replace(/√¢‚Ç¨"/g, '‚Äî');  // Em dash
                text = text.replace(/√¢‚Ç¨¬¢/g, '‚Ä¢');  // Bullet point
                text = text.replace(/√Ç¬Æ/g, '¬Æ');   // Registered trademark
                text = text.replace(/√Ç /g, ' ');   // Non-breaking space
                text = text.replace(/√Ç/g, '');     // Standalone √Ç
                
                // Additional common encoding issues
                text = text.replace(/√¢‚Ç¨¬¶/g, '‚Ä¶');   // Ellipsis
                text = text.replace(/√¢‚Ç¨‚Ñ¢s/g, "'s"); // Possessive 
                text = text.replace(/√¢‚Ç¨≈ì/g, '"');   // Opening quote
                text = text.replace(/√¢‚Ç¨/g, '"');    // Closing quote
                text = text.replace(/√¢ÀÜ'/g, '‚Ä≤');   // Prime symbol
                text = text.replace(/√¢‚Äû¬¢/g, '‚Ñ¢');   // Trademark
                text = text.replace(/√Ç¬°/g, '¬°');    // Inverted exclamation
                text = text.replace(/√Ç¬ø/g, '¬ø');    // Inverted question mark
                
                // Specific patterns from the user's file
                text = text.replace(/customers√¢/g, "customers'");
                text = text.replace(/Red Hat√Ç¬Æ/g, "Red Hat¬Æ");
                text = text.replace(/√¢([a-z])/g, "'$1");    // √¢ followed by letter becomes '
                text = text.replace(/([a-z])√¢/g, "$1'");    // letter followed by √¢ becomes '
                text = text.replace(/√¢\s/g, "' ");         // √¢ followed by space becomes '
                text = text.replace(/\s√¢/g, " '");         // space followed by √¢ becomes '
                
                // Fix corrupted "s" character - using Unicode escape for the problematic character
                text = text.replace(/\uFFFD/g, "s");            // replacement character becomes "s"
                text = text.replace(/([a-z])\uFFFD/g, "$1s");   // letter followed by replacement char becomes letter + "s"
                text = text.replace(/\s\uFFFD/g, " s");         // space followed by replacement char becomes space + "s"
                text = text.replace(/([A-Z])\uFFFD/g, "$1s");   // capital letter followed by replacement char becomes capital + "s"
                
                // More comprehensive cleanup
                text = text.replace(/√¢+/g, "'");           // Multiple √¢ becomes single '
                text = text.replace(/√Ç+/g, " ");           // Multiple √Ç becomes single space
                
                // Remove extra spaces around punctuation
                text = text.replace(/\s+([,.!?;:])/g, '$1');
                text = text.replace(/([,.!?;:])\s+/g, '$1 ');
                
                // Final cleanup - remove any remaining problematic characters
                text = text.replace(/[√¢‚Ç¨‚Ñ¢√¢‚Ç¨≈ì√¢‚Ç¨√¢‚Ç¨"√¢‚Ç¨¬¢]/g, function(match) {
                    switch(match) {
                        case '√¢‚Ç¨‚Ñ¢': return "'";
                        case '√¢‚Ç¨≈ì': return '"';
                        case '√¢‚Ç¨': return '"';
                        case '√¢‚Ç¨"': return '‚Äî';
                        case '√¢‚Ç¨¬¢': return '‚Ä¢';
                        default: return "'";
                    }
                });
                
                // Catch any remaining √¢ that wasn't handled
                text = text.replace(/√¢/g, "'");
                text = text.replace(/√Ç/g, " ");
                
                // Final pass for corrupted "s" character
                text = text.replace(/\uFFFD/g, "s");
                
                // Aggressive character replacement for encoding issues
                text = text.replace(/‚Ç¨/g, "s");                 // euro symbol becomes "s"
                text = text.replace(/\u20AC/g, "s");            // Unicode euro symbol becomes "s"
                text = text.replace(/\u2019/g, "'s");           // Right single quotation mark becomes 's
                text = text.replace(/\u2018/g, "'s");           // Left single quotation mark becomes 's
                text = text.replace(/\u201C/g, "'s");           // Left double quotation mark becomes 's
                text = text.replace(/\u201D/g, "'s");           // Right double quotation mark becomes 's
                text = text.replace(/'/g, "'s");                // Any remaining ' becomes 's
                text = text.replace(/√¢‚Ç¨‚Ñ¢/g, "'s");              // Common encoding pattern becomes 's
                text = text.replace(/√¢‚Ç¨≈ì/g, "'s");              // Common encoding pattern becomes 's
                text = text.replace(/√¢‚Ç¨/g, "'s");               // Common encoding pattern becomes 's
                text = text.replace(/s‚Ç¨/g, "s");                // s followed by euro becomes just s
                text = text.replace(/‚Ç¨/g, "");                  // Any remaining euro becomes empty
                
                // Final aggressive cleanup for any remaining problematic characters
                text = text.replace(/s[^\w\s]/g, "s");          // s followed by any non-word/non-space character becomes just s
                const beforeUrlCleanup = text;
                text = text.replace(/[^\w\s.,!?;:'"()\/\-:]/g, "");  // Remove any remaining special characters except basic punctuation and URL characters
                
                // Debug URL processing
                if (beforeUrlCleanup.includes('https') || beforeUrlCleanup.includes('http')) {
                    console.log('üîó URL processing in cleanCharacterEncoding:');
                    console.log('Before:', beforeUrlCleanup.substring(beforeUrlCleanup.indexOf('http'), beforeUrlCleanup.indexOf('http') + 50));
                    console.log('After:', text.substring(text.indexOf('http'), text.indexOf('http') + 50));
                }
                
                return text;
            }

            async extractPdfText(pdfFile) {
                try {
                    // Configure PDF.js worker
                    pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
                    
                    // Get PDF data as array buffer
                    const pdfData = await pdfFile.async('arraybuffer');
                    
                    // Load PDF document
                    const pdf = await pdfjsLib.getDocument({data: pdfData}).promise;
                    
                    let fullText = '';
                    
                    // Extract text from each page
                    for (let pageNum = 1; pageNum <= pdf.numPages; pageNum++) {
                        const page = await pdf.getPage(pageNum);
                        const textContent = await page.getTextContent();
                        
                        // Combine text items from the page
                        const pageText = textContent.items
                            .map(item => item.str)
                            .join(' ')
                            .trim();
                        
                        if (pageText) {
                            fullText += pageText + '\n\n';
                        }
                    }
                    
                    // Clean up the extracted text
                    fullText = fullText.trim();
                    fullText = this.cleanCharacterEncoding(fullText);
                    fullText = this.removeFillerText(fullText);
                    
                    return fullText;
                    
                } catch (error) {
                    console.log('PDF extraction error:', error);
                    return null;
                }
            }

            async checkForTranscriptPdf(mediaContent, mediaTitle, lessonTitle = '', sectionContext = '') {
                if (!this.currentZip) return;
                
                // Initialize transcript cache if it doesn't exist
                if (!this.transcriptCache) {
                    this.transcriptCache = new Map();
                }
                

                
                // First, try to find transcript attachments in the media item
                const transcriptAttachments = this.findTranscriptAttachments({ media: { embed: { title: mediaTitle } } });
                if (transcriptAttachments.length > 0) {
                    for (const attachment of transcriptAttachments) {
                        await this.extractTranscriptFromAttachment(attachment, mediaContent);
                    }
                    return;
                }
                
                // Clean and normalize titles for matching
                const cleanMediaTitle = this.normalizeForMatching(mediaTitle);
                const cleanLessonTitle = this.normalizeForMatching(lessonTitle);
                const cleanSectionContext = this.normalizeForMatching(sectionContext);
                
                // Create additional normalized versions for better matching
                const camelCaseMediaTitle = this.toCamelCase(mediaTitle);
                const camelCaseLessonTitle = this.toCamelCase(lessonTitle);
                
                // Create context-specific matching patterns
                const contextualPatterns = [
                    // Exact media title matches
                    `${cleanMediaTitle}_transcript.pdf`,
                    `${cleanMediaTitle}-transcript.pdf`,
                    `transcript_${cleanMediaTitle}.pdf`,
                    `transcript-${cleanMediaTitle}.pdf`,
                    `${cleanMediaTitle}.transcript.pdf`,
                    
                    // Video Transcript patterns (common in Rise courses)
                    `videotranscript_${cleanMediaTitle}.pdf`,
                    `video_transcript_${cleanMediaTitle}.pdf`,
                    `videotranscript${cleanMediaTitle}.pdf`,
                    
                    // Lesson-specific matches
                    ...(cleanLessonTitle ? [
                        `${cleanLessonTitle}_${cleanMediaTitle}_transcript.pdf`,
                        `${cleanLessonTitle}-${cleanMediaTitle}-transcript.pdf`,
                        `${cleanLessonTitle}_transcript.pdf`,
                        `${cleanLessonTitle}-transcript.pdf`,
                        `transcript_${cleanLessonTitle}.pdf`,
                        `transcript-${cleanLessonTitle}.pdf`,
                        `videotranscript_${cleanLessonTitle}.pdf`,
                        `video_transcript_${cleanLessonTitle}.pdf`
                    ] : []),
                    
                    // Section-specific matches
                    ...(cleanSectionContext ? [
                        `${cleanSectionContext}_transcript.pdf`,
                        `${cleanSectionContext}-transcript.pdf`,
                        `transcript_${cleanSectionContext}.pdf`,
                        `transcript-${cleanSectionContext}.pdf`
                    ] : [])
                ];
                
                // Collect all potential transcript PDFs with scoring
                const transcriptCandidates = [];
                
                for (const [filePath, zipEntry] of Object.entries(this.currentZip.files)) {
                    if (filePath.toLowerCase().endsWith('.pdf')) {
                        const fileName = filePath.split('/').pop().toLowerCase();
                        const cleanFileName = this.normalizeForMatching(fileName.replace('.pdf', ''));
                        
                        // Create a unique cache key that includes all context
                        const cacheKey = `${filePath}_${cleanMediaTitle}_${cleanLessonTitle}_${cleanSectionContext}`;
                        if (this.transcriptCache.has(cacheKey)) {
                            const cachedResult = this.transcriptCache.get(cacheKey);
                            if (cachedResult) {

                                console.log(`Using cached transcript from ${fileName} for ${mediaTitle} with context ${cleanLessonTitle}/${cleanSectionContext}`);
                                return;
                            }
                            continue; // Skip if cached as non-matching for this specific context
                        }
                        
                        // Score the PDF based on how well it matches our context
                        let matchScore = 0;
                        let matchReasons = [];
                        
                        // Exact contextual pattern matches (highest priority)
                        const exactMatch = contextualPatterns.find(pattern => fileName === pattern);
                        if (exactMatch) {
                            matchScore += 100;
                            matchReasons.push(`exact pattern match: ${exactMatch}`);
                        }
                        
                        // Partial matches with media title
                        if (cleanMediaTitle && cleanFileName.includes(cleanMediaTitle)) {
                            matchScore += 50;
                            matchReasons.push(`contains media title: ${cleanMediaTitle}`);
                        }
                        
                        // Special handling for "Video Transcript_" pattern files
                        if (fileName.startsWith('video transcript') || fileName.startsWith('videotranscript')) {
                            // Check if the filename contains words from the media title
                            const mediaWords = cleanMediaTitle.split(/[^a-z0-9]+/).filter(w => w.length > 2);
                            const fileNameWords = cleanFileName.split(/[^a-z0-9]+/).filter(w => w.length > 2);
                            
                            let wordMatches = 0;
                            for (const mediaWord of mediaWords) {
                                if (fileNameWords.some(fileWord => fileWord.includes(mediaWord) || mediaWord.includes(fileWord))) {
                                    wordMatches++;
                                }
                            }
                            
                            // Also check camelCase matching for patterns like "WhatIsAnOperatingSystem"
                            if (camelCaseMediaTitle && cleanFileName.includes(camelCaseMediaTitle.toLowerCase())) {
                                matchScore += 70;
                                matchReasons.push(`camelCase title match: ${camelCaseMediaTitle}`);
                            }
                            
                            if (mediaWords.length > 0) {
                                const wordMatchRatio = wordMatches / mediaWords.length;
                                if (wordMatchRatio >= 0.5) { // At least 50% of words match
                                    matchScore += 60;
                                    matchReasons.push(`video transcript pattern with ${Math.round(wordMatchRatio * 100)}% word match`);
                                } else if (wordMatchRatio > 0) {
                                    matchScore += 25;
                                    matchReasons.push(`video transcript pattern with ${Math.round(wordMatchRatio * 100)}% word match`);
                                }
                            }
                        }
                        
                        // Check for camelCase matches in any transcript file
                        if (camelCaseMediaTitle && cleanFileName.includes(camelCaseMediaTitle.toLowerCase())) {
                            matchScore += 45;
                            matchReasons.push(`camelCase pattern match: ${camelCaseMediaTitle}`);
                        }
                        
                        // Enhanced matching with media metadata patterns
                        if (cleanMediaTitle) {
                            // Check for common video ID patterns in transcript filenames
                            if (cleanMediaTitle.includes('youtube') && cleanFileName.includes('youtube')) {
                                matchScore += 40;
                                matchReasons.push('YouTube video ID match');
                            }
                            if (cleanMediaTitle.includes('vimeo') && cleanFileName.includes('vimeo')) {
                                matchScore += 40;
                                matchReasons.push('Vimeo video ID match');
                            }
                            
                            // Check for duration-based matching (if transcript filename contains duration info)
                            const durationMatch = cleanFileName.match(/(\d+)min|(\d+)m(\d+)s|(\d+)sec/);
                            if (durationMatch && cleanMediaTitle.includes('min')) {
                                matchScore += 15;
                                matchReasons.push('duration pattern match');
                            }
                        }
                        
                        // Partial matches with lesson title
                        if (cleanLessonTitle && cleanFileName.includes(cleanLessonTitle)) {
                            matchScore += 30;
                            matchReasons.push(`contains lesson title: ${cleanLessonTitle}`);
                        }
                        
                        // Partial matches with section context
                        if (cleanSectionContext && cleanFileName.includes(cleanSectionContext)) {
                            matchScore += 20;
                            matchReasons.push(`contains section context: ${cleanSectionContext}`);
                        }
                        
                        // Generic transcript indicators (lowest priority)
                        if (fileName.includes('transcript')) {
                            matchScore += 5;
                            matchReasons.push('contains "transcript"');
                        }
                        
                        // Penalty for mismatched content - check if transcript filename suggests different content
                        if (cleanMediaTitle) {
                            // If media is about "operating system" but transcript is about "security", penalize heavily
                            const mediaKeywords = cleanMediaTitle.split(/[^a-z0-9]+/).filter(w => w.length > 2);
                            const transcriptKeywords = cleanFileName.split(/[^a-z0-9]+/).filter(w => w.length > 2);
                            
                            // Check for topic mismatch
                            const hasMediaKeywordMatch = mediaKeywords.some(keyword => 
                                transcriptKeywords.some(tKeyword => tKeyword.includes(keyword) || keyword.includes(tKeyword))
                            );
                            
                            if (mediaKeywords.length > 0 && transcriptKeywords.length > 2 && !hasMediaKeywordMatch) {
                                matchScore -= 25; // Heavy penalty for topic mismatch
                                matchReasons.push('potential topic mismatch penalty');
                            }
                        }
                        
                        // Check if filename is in the same directory as media (path-based matching)
                        const mediaPath = filePath.split('/').slice(0, -1).join('/');
                        if (mediaPath && cleanFileName.includes('transcript')) {
                            matchScore += 10;
                            matchReasons.push('same directory as media');
                        }
                        
                        // Only consider files with meaningful relevance (minimum score threshold)
                        if (matchScore >= 25) { // Require at least a decent match score
                            transcriptCandidates.push({
                                filePath,
                                fileName,
                                zipEntry,
                                matchScore,
                                matchReasons,
                                cacheKey
                            });
                        }
                    }
                }
                
                // Sort candidates by match score (highest first)
                transcriptCandidates.sort((a, b) => b.matchScore - a.matchScore);
                
                // Debug output for transcript matching
                console.log(`\n=== Transcript matching for "${mediaTitle}" in lesson "${lessonTitle}" section "${sectionContext}" ===`);
                console.log(`Normalized titles: media="${cleanMediaTitle}", camelCase="${camelCaseMediaTitle}", lesson="${cleanLessonTitle}"`);
                
                // Show all PDF files found for debugging
                const allPdfs = Object.keys(this.currentZip.files).filter(path => path.toLowerCase().endsWith('.pdf'));
                console.log(`All PDF files in package: ${allPdfs.join(', ')}`);
                
                console.log(`Found ${transcriptCandidates.length} transcript candidates`);
                
                if (transcriptCandidates.length === 0) {
                    console.log(`No transcript candidates met minimum score threshold of 25`);
                }
                
                // Try to extract from the best matching candidates
                for (const candidate of transcriptCandidates) {
                    console.log(`Trying transcript candidate: ${candidate.fileName} (score: ${candidate.matchScore}, reasons: ${candidate.matchReasons.join(', ')})`);
                    
                    try {
                        const pdfText = await this.extractPdfText(candidate.zipEntry);
                        if (pdfText && pdfText.length > 50) {
                            // Additional content relevance check
                            const contentRelevanceScore = this.calculateContentRelevance(mediaTitle, lessonTitle, pdfText);
                            console.log(`Content relevance score for ${candidate.fileName}: ${contentRelevanceScore}`);
                            
                            // Only use transcript if content is somewhat relevant or if we have a very high filename match
                            if (contentRelevanceScore >= 0.3 || candidate.matchScore >= 75) {
                                // Cache the successful result
                                this.transcriptCache.set(candidate.cacheKey, pdfText);
                                

                                console.log(`‚úÖ Successfully extracted transcript from ${candidate.fileName} for ${mediaTitle} (filename score: ${candidate.matchScore}, content relevance: ${contentRelevanceScore})`);
                                return;
                            } else {
                                console.log(`‚ùå Content relevance too low (${contentRelevanceScore}) for ${candidate.fileName} - skipping`);
                                // Cache as non-matching for this context
                                this.transcriptCache.set(candidate.cacheKey, null);
                            }
                        } else {
                            console.log(`‚ùå PDF text too short or empty for ${candidate.fileName}`);
                            // Cache the failed result to avoid re-processing
                            this.transcriptCache.set(candidate.cacheKey, null);
                        }
                    } catch (error) {
                        console.log(`‚ùå Failed to extract text from ${candidate.fileName}:`, error);
                        // Cache the failed result
                        this.transcriptCache.set(candidate.cacheKey, null);
                    }
                }
                
                console.log(`No suitable transcript found for ${mediaTitle} in lesson "${lessonTitle}" section "${sectionContext}"`);
            }
            
                    extractActualFilename(encodedFilename) {
            if (!encodedFilename) return '';

            console.log('üîç Extracting actual filename from:', encodedFilename);

            // Look for the pattern: PREFIX-Video%20Transcript_ACTUALNAME
            const match = encodedFilename.match(/.*?-Video%20Transcript_(.+)/);
            if (match) {
                const actualPart = match[1];
                // Decode URL encoding
                const decoded = decodeURIComponent(actualPart);
                console.log('‚úÖ Extracted actual filename:', decoded);
                return decoded;
            }

            // Fallback: try to find "Video Transcript_" anywhere in the string
            const transcriptMatch = encodedFilename.match(/Video%20Transcript_(.+)/);
            if (transcriptMatch) {
                const actualPart = transcriptMatch[1];
                const decoded = decodeURIComponent(actualPart);
                console.log('‚úÖ Extracted actual filename (fallback):', decoded);
                return decoded;
            }

            // If no pattern found, return the original filename decoded
            const decoded = decodeURIComponent(encodedFilename);
            console.log('‚ö†Ô∏è No pattern found, using decoded filename:', decoded);
            return decoded;
        }

        // Map originalUrl to actual filename in ZIP
        mapOriginalUrlToZipFilename(originalUrl) {
            if (!originalUrl) return null;

            console.log('üó∫Ô∏è Mapping originalUrl to ZIP filename:', originalUrl);

            // The pattern we see: originalUrl has spaces and brackets, ZIP filename has underscores
            // Example: "Video Transcript_WhatIsAnOperatingSystem_[2025].pdf" -> "Video Transcript_WhatIsAnOperatingSystem_[2025_.pdf"
            
            // The actual files in the ZIP still have spaces, so don't replace them
            // Just replace closing brackets with underscores to match the pattern
            let zipFilename = originalUrl
                .replace(/‚Ç¨/g, 's')    // Replace euro symbol with 's'
                .replace(/\]/g, '_')   // Replace closing bracket with underscore
                .replace(/_{2,}/g, '_'); // Replace 2 or more underscores with single underscore

            console.log('‚úÖ Mapped to ZIP filename:', zipFilename);
            return zipFilename;
        }
            
            findMatchingTranscript(videoTitle, lessonTitle) {
                if (!this.transcriptAttachments || this.transcriptAttachments.size === 0) {
                    return null;
                }
                
                console.log(`üîç Looking for transcript matching video: "${videoTitle}" in lesson: "${lessonTitle}"`);
                console.log(`üìö Available transcripts:`, Array.from(this.transcriptAttachments.keys()));
                
                // Try to find a transcript that matches the video title or lesson context
                for (const [transcriptUrl, transcriptData] of this.transcriptAttachments) {
                    const transcriptTitle = transcriptData.attachment.originalUrl || transcriptData.attachment.filename;
                    
                    // Check if transcript is from the same lesson
                    if (transcriptData.lesson === lessonTitle) {
                        console.log(`‚úÖ Found transcript from same lesson: ${transcriptTitle}`);
                        return {
                            href: transcriptData.attachment.key || transcriptData.attachment.originalUrl,
                            download: transcriptData.attachment.filename,
                            title: transcriptTitle,
                            size: transcriptData.attachment.size,
                            mimeType: transcriptData.attachment.mimeType
                        };
                    }
                }
                
                // If no lesson match, try to find by content similarity
                for (const [transcriptUrl, transcriptData] of this.transcriptAttachments) {
                    const transcriptTitle = transcriptData.attachment.originalUrl || transcriptData.attachment.filename;
                    
                    // Extract key words from video title and transcript title
                    const videoWords = videoTitle.toLowerCase().split(/\s+/).filter(w => w.length > 2);
                    const transcriptWords = transcriptTitle.toLowerCase().split(/\s+/).filter(w => w.length > 2);
                    
                    // Check for word overlap
                    const matches = videoWords.filter(vWord => 
                        transcriptWords.some(tWord => tWord.includes(vWord) || vWord.includes(tWord))
                    );
                    
                    if (matches.length > 0) {
                        console.log(`‚úÖ Found transcript with word matches: ${transcriptTitle} (matches: ${matches.join(', ')})`);
                        return {
                            href: transcriptData.attachment.key || transcriptData.attachment.originalUrl,
                            download: transcriptData.attachment.filename,
                            title: transcriptTitle,
                            size: transcriptData.attachment.size,
                            mimeType: transcriptData.attachment.mimeType
                        };
                    }
                }
                
                console.log(`‚ùå No matching transcript found for video: "${videoTitle}"`);
                return null;
            }
            
            findTranscriptAttachments(item) {
                const attachments = [];
                
                console.log('üîç Checking for transcript attachments in item:', item);
                
                // Check for transcript attachments in the media.attachment structure
                if (item.media?.attachment) {
                    const attachment = item.media.attachment;
                    console.log('üìé Found attachment:', attachment);
                    
                    // Check if this is a transcript attachment
                    if (attachment.filename && 
                        (attachment.filename.toLowerCase().includes('transcript') || 
                         attachment.originalUrl?.toLowerCase().includes('transcript'))) {
                        
                        console.log('‚úÖ Found transcript attachment:', attachment.filename);
                        attachments.push({
                            href: attachment.key || attachment.originalUrl,
                            download: attachment.filename,
                            title: attachment.originalUrl || attachment.filename,
                            size: attachment.size,
                            mimeType: attachment.mimeType
                        });
                    } else {
                        console.log('‚ùå Attachment is not a transcript:', attachment.filename);
                    }
                } else {
                    console.log('‚ùå No attachment found in media');
                }
                
                // Also check for transcript attachments in HTML content as fallback
                const possibleHtmlContent = [
                    item.media?.embed?.html,
                    item.media?.embed?.content,
                    item.media?.audio?.html,
                    item.media?.audio?.content,
                    item.html,
                    item.content,
                    item.description
                ];
                
                for (const htmlContent of possibleHtmlContent) {
                    if (htmlContent && typeof htmlContent === 'string') {
                        // Parse HTML content for transcript attachments
                        const parser = new DOMParser();
                        const doc = parser.parseFromString(htmlContent, 'text/html');
                        
                        // Find all <a> tags with download attributes containing "transcript"
                        const transcriptLinks = doc.querySelectorAll('a[download*="transcript"], a[download*="Transcript"]');
                        
                        transcriptLinks.forEach(link => {
                            const href = link.getAttribute('href');
                            const download = link.getAttribute('download');
                            const title = link.textContent?.trim() || download;
                            
                            if (href && download) {
                                attachments.push({
                                    href: href,
                                    download: download,
                                    title: title
                                });
                            }
                        });
                        
                        // If we found attachments, no need to check other content
                        if (attachments.length > 0) break;
                    }
                }
                
                return attachments;
            }
            
                    async extractTranscriptFromAttachment(attachment, mediaContent) {
            try {
                console.log('üìÑ Extracting transcript from attachment:', attachment);

                // Map the originalUrl to the actual ZIP filename
                let zipFilename = this.mapOriginalUrlToZipFilename(attachment.title);
                if (!zipFilename) {
                    console.log('‚ùå Could not map originalUrl to ZIP filename');
                    return;
                }

                // Construct the full path to the transcript file
                let transcriptPath = `scormcontent/assets/${zipFilename}`;

                console.log(`üîç Looking for transcript at path: ${transcriptPath}`);

                // Check if the file exists in the zip
                const transcriptFile = this.currentZip.files[transcriptPath];
                if (!transcriptFile) {
                    console.log(`Transcript file not found at path: ${transcriptPath}`);
                    return;
                }

                // Extract text from the PDF
                const pdfText = await this.extractPdfText(transcriptFile);
                if (pdfText && pdfText.length > 50) {
                    // Add transcript directly to the media content
                    mediaContent.push(`\n**üìÑ Transcript (${attachment.title}):**`);
                    mediaContent.push(pdfText);
                    console.log(`‚úÖ Successfully extracted transcript from attachment: ${attachment.title}`);
                } else {
                    console.log(`‚ùå PDF text too short or empty for: ${attachment.title}`);
                }

            } catch (error) {
                console.log(`‚ùå Failed to extract transcript from attachment: ${attachment.title}`, error);
            }
            }
            
            normalizeForMatching(text) {
                if (!text) return '';
                return text.toLowerCase()
                    .replace(/[^a-z0-9]/g, '') // Remove all non-alphanumeric characters
                    .trim();
            }
            
            toCamelCase(text) {
                if (!text) return '';
                return text.toLowerCase()
                    .replace(/[^a-z0-9\s]/g, '') // Keep only letters, numbers, and spaces
                    .split(/\s+/)
                    .map((word, index) => index === 0 ? word : word.charAt(0).toUpperCase() + word.slice(1))
                    .join('');
            }
            
            calculateContentRelevance(mediaTitle, lessonTitle, transcriptText) {
                // Calculate how relevant the transcript content is to the media/lesson
                if (!transcriptText || transcriptText.length < 50) return 0;
                
                const normalizeText = (text) => text.toLowerCase().replace(/[^a-z0-9\s]/g, ' ').replace(/\s+/g, ' ').trim();
                
                const normalizedTranscript = normalizeText(transcriptText);
                const normalizedMediaTitle = normalizeText(mediaTitle || '');
                const normalizedLessonTitle = normalizeText(lessonTitle || '');
                
                let relevanceScore = 0;
                let totalChecks = 0;
                
                // Extract key terms from media and lesson titles
                const mediaKeywords = normalizedMediaTitle.split(' ').filter(w => w.length > 2);
                const lessonKeywords = normalizedLessonTitle.split(' ').filter(w => w.length > 2);
                const allKeywords = [...new Set([...mediaKeywords, ...lessonKeywords])];
                
                console.log(`Checking content relevance for keywords: ${allKeywords.join(', ')}`);
                
                // Check for keyword matches in transcript
                for (const keyword of allKeywords) {
                    totalChecks++;
                    if (normalizedTranscript.includes(keyword)) {
                        relevanceScore++;
                        console.log(`‚úì Found keyword "${keyword}" in transcript`);
                    } else {
                        console.log(`‚úó Keyword "${keyword}" not found in transcript`);
                    }
                }
                
                // Special case: if media is about "operating system" but transcript is about "security", it's likely wrong
                const topicMismatchKeywords = {
                    'operating system': ['security', 'compliance', 'threat', 'vulnerability'],
                    'linux': ['security', 'compliance', 'threat', 'vulnerability'],
                    'security': ['operating', 'linux', 'kernel'],
                    'rhel': [] // RHEL can be about anything
                };
                
                for (const [topic, conflictingTerms] of Object.entries(topicMismatchKeywords)) {
                    if (normalizedMediaTitle.includes(topic) || normalizedLessonTitle.includes(topic)) {
                        for (const conflictTerm of conflictingTerms) {
                            if (normalizedTranscript.includes(conflictTerm) && 
                                !normalizedTranscript.includes(topic) &&
                                !normalizedMediaTitle.includes(conflictTerm) &&
                                !normalizedLessonTitle.includes(conflictTerm)) {
                                relevanceScore -= 0.5; // Penalty for topic mismatch
                                console.log(`‚ö†Ô∏è  Topic mismatch: media about "${topic}" but transcript focuses on "${conflictTerm}"`);
                            }
                        }
                    }
                }
                
                // Calculate final score
                const finalScore = totalChecks > 0 ? Math.max(0, relevanceScore / totalChecks) : 0;
                console.log(`Content relevance calculation: ${relevanceScore}/${totalChecks} = ${finalScore}`);
                
                return finalScore;
            }
            
            extractMediaMetadata(item) {
                // Extract comprehensive metadata from media items for better transcript matching
                const metadata = {
                    title: '',
                    description: '',
                    filename: '',
                    duration: '',
                    videoId: '',
                    type: 'unknown'
                };
                
                if (item.media) {
                    // Video metadata
                    if (item.media.embed) {
                        metadata.type = 'video';
                        metadata.title = item.media.embed.title || item.title || '';
                        metadata.description = item.media.embed.description || '';
                        metadata.duration = item.media.embed.duration || '';
                        
                        if (item.media.embed.src) {
                            // Extract video ID from YouTube or Vimeo
                            const youtubeMatch = item.media.embed.src.match(/youtube\.com\/embed\/([^?"]+)/);
                            const vimeoMatch = item.media.embed.src.match(/vimeo\.com\/video\/([^?"]+)/);
                            
                            if (youtubeMatch) {
                                metadata.videoId = youtubeMatch[1];
                                metadata.filename = `youtube_${youtubeMatch[1]}`;
                            } else if (vimeoMatch) {
                                metadata.videoId = vimeoMatch[1];
                                metadata.filename = `vimeo_${vimeoMatch[1]}`;
                            }
                        }
                    }
                    // Audio metadata
                    else if (item.media.audio) {
                        metadata.type = 'audio';
                        metadata.title = item.media.audio.title || item.title || '';
                        metadata.description = item.media.audio.description || '';
                        metadata.duration = item.media.audio.duration || '';
                        
                        if (item.media.audio.src) {
                            metadata.filename = item.media.audio.src.split('/').pop() || '';
                        }
                    }
                    // Image metadata
                    else if (item.media.image) {
                        metadata.type = 'image';
                        metadata.title = item.media.image.title || item.title || '';
                        metadata.description = item.media.image.description || item.media.image.alt || '';
                        
                        if (item.media.image.src) {
                            metadata.filename = item.media.image.src.split('/').pop() || '';
                        }
                    }
                }
                
                // Fallback to item-level properties
                if (!metadata.title && item.title) {
                    metadata.title = item.title;
                }
                if (!metadata.description && item.description) {
                    metadata.description = item.description;
                }
                
                return metadata;
            }
            
            removeFillerText(text) {
                if (!text || text.length < 10) return text;
                
                // Common filler text patterns
                const fillerPatterns = [
                    // Lorem ipsum variations
                    /lorem ipsum.*?(?=\.|$)/gi,
                    /ipsum dolor.*?(?=\.|$)/gi,
                    /dolor sit amet.*?(?=\.|$)/gi,
                    /consectetur adipiscing elit.*?(?=\.|$)/gi,
                    /sed do eiusmod tempor.*?(?=\.|$)/gi,
                    /ut labore et dolore.*?(?=\.|$)/gi,
                    /magna aliqua.*?(?=\.|$)/gi,
                    /enim ad minim veniam.*?(?=\.|$)/gi,
                    /quis nostrud exercitation.*?(?=\.|$)/gi,
                    /ullamco laboris.*?(?=\.|$)/gi,
                    /duis aute irure.*?(?=\.|$)/gi,
                    /excepteur sint occaecat.*?(?=\.|$)/gi,
                    
                    // Full lorem ipsum sentences
                    /Lorem ipsum dolor sit amet, consectetur adipiscing elit\..*?(?=\n|$)/gi,
                    /In purus velit, tincidunt ac nibh quis, sollicitudin varius libero\..*?(?=\n|$)/gi,
                    /Nullam at mi felis\..*?(?=\n|$)/gi,
                    /Donec a scelerisque augue, sit amet porttitor nibh\..*?(?=\n|$)/gi,
                    /Suspendisse at lorem ut elit placerat blandit\..*?(?=\n|$)/gi,
                    
                    // Common placeholder text
                    /placeholder text.*?(?=\.|$)/gi,
                    /sample text.*?(?=\.|$)/gi,
                    /dummy text.*?(?=\.|$)/gi,
                    /example content.*?(?=\.|$)/gi,
                    /test content.*?(?=\.|$)/gi,
                    /filler text.*?(?=\.|$)/gi,
                    
                    // Generic summary patterns that are just "Summary: Summary"
                    /^Summary:\s*Summary\s*$/gi,
                    /^Description:\s*Description\s*$/gi,
                    /^Content:\s*Content\s*$/gi,
                    /^Title:\s*Title\s*$/gi,
                    
                    // Repetitive placeholder patterns
                    /^(.*?)\s*:\s*\1\s*$/gi, // Matches "Word: Word" patterns
                    
                    // Common template text
                    /this is a placeholder.*?(?=\.|$)/gi,
                    /replace this text.*?(?=\.|$)/gi,
                    /add your content here.*?(?=\.|$)/gi,
                    /insert content here.*?(?=\.|$)/gi,
                    /content goes here.*?(?=\.|$)/gi,
                    /your text here.*?(?=\.|$)/gi,
                    
                    // Development/testing text
                    /test test test.*?(?=\.|$)/gi,
                    /hello world.*?(?=\.|$)/gi,
                    /testing 123.*?(?=\.|$)/gi,
                    /this is a test.*?(?=\.|$)/gi,
                ];
                
                // Apply all filler text removal patterns
                let cleanedText = text;
                fillerPatterns.forEach(pattern => {
                    cleanedText = cleanedText.replace(pattern, '');
                });
                
                // Clean up empty lines and extra whitespace after removal
                cleanedText = cleanedText.replace(/\n\s*\n\s*\n/g, '\n\n'); // Multiple empty lines to double
                cleanedText = cleanedText.replace(/^\s*\n+/, ''); // Leading empty lines
                cleanedText = cleanedText.replace(/\n+\s*$/, ''); // Trailing empty lines
                cleanedText = cleanedText.replace(/\s+/g, ' ').trim(); // Multiple spaces to single
                
                // If the entire text was filler, return empty string
                if (cleanedText.length < 3 || /^[.\s,:-]*$/.test(cleanedText)) {
                    return '';
                }
                
                return cleanedText;
            }
            
            cleanHtmlText(htmlString) {
                if (!htmlString) return '';
                
                // Create a temporary element to parse HTML
                const temp = document.createElement('div');
                temp.innerHTML = htmlString;
                
                // Remove script, style, and other unwanted elements
                const unwantedElements = temp.querySelectorAll('script, style, header, footer, nav');
                unwantedElements.forEach(el => el.remove());
                
                // Handle images to prevent browser from trying to load them
                const images = temp.querySelectorAll('img');
                images.forEach(img => {
                    const src = img.getAttribute('src');
                    const alt = img.getAttribute('alt') || '';
                    
                    if (src) {
                        const filename = src.split('/').pop();
                        // Replace image with text description
                        img.outerHTML = alt ? `[Image: ${alt} (${filename})]` : `[Image: ${filename}]`;
                    } else {
                        img.remove();
                    }
                });
                
                // Extract and format hyperlinks before getting text content
                const links = temp.querySelectorAll('a[href]');
                links.forEach(link => {
                    const href = link.getAttribute('href');
                    const linkText = link.textContent || link.innerText || '';
                    
                    // Skip if it's just an anchor link or empty
                    if (!href || href.startsWith('#') || !linkText.trim()) {
                        return;
                    }
                    
                    // Replace the link with formatted text
                    // Debug URL before processing
                    if (href.includes('http')) {
                        console.log('üîó Processing link href:', href);
                    }
                    
                    // Fix broken URLs that lost their colon
                    let fixedHref = href;
                    if (href.includes('https//') && !href.includes('https://')) {
                        fixedHref = href.replace(/https\/\//g, 'https://');
                        console.log('üîß Fixed broken href:', href, '‚Üí', fixedHref);
                    }
                    if (href.includes('http//') && !href.includes('http://') && !href.includes('https://')) {
                        fixedHref = href.replace(/http\/\//g, 'http://');
                        console.log('üîß Fixed broken href:', href, '‚Üí', fixedHref);
                    }
                    
                    if (linkText.trim() && fixedHref !== linkText.trim()) {
                        // Link text is different from URL
                        link.outerHTML = `${linkText} (${fixedHref})`;
                    } else if (linkText.trim()) {
                        // Link text is same as URL or just show URL
                        link.outerHTML = `${linkText} (${fixedHref})`;
                    } else {
                        // No link text, just show URL
                        link.outerHTML = `(${fixedHref})`;
                    }
                });
                
                // Get text content and clean it up
                let text = temp.textContent || temp.innerText || '';
                
                // Debug: check if URLs are intact in the raw text
                if (text.includes('https://')) {
                    console.log('üîó Raw text contains https://, URLs should be intact');
                } else if (text.includes('https//')) {
                    console.log('‚ö†Ô∏è Raw text already missing colon - issue is in DOM processing');
                    console.log('üîç Sample broken URL:', text.substring(text.indexOf('https//'), text.indexOf('https//') + 60));
                }
                
                // CAPTURE ALL BROKEN URLs FOR OUTPUT FILE
                // Look for URLs missing colon: https// or http// patterns (note: no colon after https)
                const brokenUrlMatches = text.match(/https\/\/[^\s\)]+/g) || [];
                if (brokenUrlMatches.length > 0) {
                    console.log('üìã BROKEN URLs FOUND - Adding to output:');
                    brokenUrlMatches.forEach(url => {
                        console.log('   BROKEN:', url);
                        // Add to a global collection for the output file
                        window.brokenUrls.add(url);
                    });
                }
                
                // ALSO capture URLs that are completely mangled (missing protocol entirely)
                const mangledUrlMatches = text.match(/content\.redhat\.com[^\s\)]+/g) || [];
                if (mangledUrlMatches.length > 0) {
                    console.log('üìã MANGLED URLs FOUND - Adding to output:');
                    mangledUrlMatches.forEach(url => {
                        console.log('   MANGLED:', url);
                        // Add to a global collection for the output file
                        window.brokenUrls.add('https://' + url); // Add the missing protocol
                    });
                }
                
                // CRITICAL FIX: Repair URLs that lost their colon during DOM text extraction
                const beforeUrlFix = text;
                
                // Debug: Show actual broken URL patterns
                if (text.includes('https//')) {
                    console.log('üîç Found broken https// pattern in text');
                    const httpsMatches = text.match(/https\/\/[^\s]*/g);
                    console.log('üîç All https// matches:', httpsMatches);
                }
                
                // COMPREHENSIVE URL REPAIR: Fix multiple URL corruption patterns
                
                // 1. Fix missing colon in https// and http//
                text = text.replace(/https\/\/([a-zA-Z0-9\-\.\/\?\&\=\%\#\-\w]*)/g, function(match, rest) {
                    if (match.startsWith('https//')) {
                        console.log('üîß Fixing missing colon in https//', match);
                        return 'https://' + rest;
                    }
                    return match;
                });
                
                text = text.replace(/http\/\/([a-zA-Z0-9\-\.\/\?\&\=\%\#\-\w]*)/g, function(match, rest) {
                    if (match.startsWith('http//')) {
                        console.log('üîß Fixing missing colon in http//', match);
                        return 'http://' + rest;
                    }
                    return match;
                });
                
                // 2. Fix severely corrupted URLs that lost slashes and have truncated paths
                text = text.replace(/https?:\/\/([a-zA-Z0-9\-\.]+)([a-zA-Z0-9\-\.\/]*)/g, function(match, domain, path) {
                    // Check for common corrupted patterns
                    if (domain.includes('contentredhat') || domain.includes('content.redhat')) {
                        let fixedDomain = 'content.redhat.com';
                        
                        // Try to reconstruct the path from the corruption
                        let fixedPath = path;
                        if (path.includes('usen')) {
                            fixedPath = '/us/en' + path.substring(path.indexOf('usen') + 4);
                        }
                        if (path.includes('product') && path.includes('productsand')) {
                            fixedPath = fixedPath.replace('productsand', '/products-and');
                        }
                        if (path.includes('salesenablement')) {
                            fixedPath = fixedPath.replace('salesenablement', '/sales-enablement');
                        }
                        
                        let protocol = match.startsWith('https') ? 'https://' : 'http://';
                        let reconstructed = protocol + fixedDomain + fixedPath;
                        
                        console.log('üîß Reconstructing corrupted URL:', match, '->', reconstructed);
                        return reconstructed;
                    }
                    return match;
                });
                
                if (beforeUrlFix !== text) {
                    console.log('üîß FIXED URLs in text content - found and repaired broken URLs');
                    const sampleBefore = beforeUrlFix.includes('https//') ? beforeUrlFix.substring(beforeUrlFix.indexOf('https//'), beforeUrlFix.indexOf('https//') + 80) : 'none';
                    const sampleAfter = text.includes('https://') ? text.substring(text.indexOf('https://'), text.indexOf('https://') + 80) : 'none';
                    console.log('üîß Before fix:', sampleBefore);
                    console.log('üîß After fix:', sampleAfter);
                } else {
                    console.log('üîç No URL changes made - checking patterns in text');
                    if (text.includes('https//')) {
                        console.log('‚ö†Ô∏è Still contains https// after fix attempt');
                    }
                    if (text.includes('content.redhat.com')) {
                        console.log('‚úì Contains proper content.redhat.com');
                    }
                    if (text.includes('contentredhat')) {
                        console.log('‚ö†Ô∏è Contains broken contentredhat pattern');
                    }
                }
                
                // Clean up common formatting issues
                text = text.replace(/\s+/g, ' ').trim();
                text = text.replace(/(\d+)of(\d+)/g, '$1 of $2');
                
                // Clean up special characters and encoding issues
                text = text.replace(/√¢‚Ç¨‚Ñ¢/g, "'");  // Right single quotation mark
                text = text.replace(/√¢‚Ç¨≈ì/g, '"');  // Left double quotation mark  
                text = text.replace(/√¢‚Ç¨/g, '"');   // Right double quotation mark
                text = text.replace(/√¢‚Ç¨"/g, '‚Äî');  // Em dash
                text = text.replace(/√¢‚Ç¨¬¢/g, '‚Ä¢');  // Bullet point
                text = text.replace(/√Ç¬Æ/g, '¬Æ');   // Registered trademark
                text = text.replace(/√Ç /g, ' ');   // Non-breaking space
                text = text.replace(/√Ç/g, '');     // Standalone √Ç
                
                // Additional common encoding issues
                text = text.replace(/√¢‚Ç¨¬¶/g, '‚Ä¶');   // Ellipsis
                text = text.replace(/√¢‚Ç¨‚Ñ¢s/g, "'s"); // Possessive 
                text = text.replace(/√¢‚Ç¨≈ì/g, '"');   // Opening quote
                text = text.replace(/√¢‚Ç¨/g, '"');    // Closing quote
                text = text.replace(/√¢ÀÜ'/g, '‚Ä≤');   // Prime symbol
                text = text.replace(/√¢‚Äû¬¢/g, '‚Ñ¢');   // Trademark
                text = text.replace(/√Ç¬°/g, '¬°');    // Inverted exclamation
                text = text.replace(/√Ç¬ø/g, '¬ø');    // Inverted question mark
                
                // Specific patterns from the user's file
                text = text.replace(/customers√¢/g, "customers'");
                text = text.replace(/Red Hat√Ç¬Æ/g, "Red Hat¬Æ");
                text = text.replace(/√¢([a-z])/g, "'$1");    // √¢ followed by letter becomes '
                text = text.replace(/([a-z])√¢/g, "$1'");    // letter followed by √¢ becomes '
                text = text.replace(/√¢\s/g, "' ");         // √¢ followed by space becomes '
                text = text.replace(/\s√¢/g, " '");         // space followed by √¢ becomes '
                
                // Fix corrupted "s" character - using Unicode escape for the problematic character
                text = text.replace(/\uFFFD/g, "s");            // replacement character becomes "s"
                text = text.replace(/([a-z])\uFFFD/g, "$1s");   // letter followed by replacement char becomes letter + "s"
                text = text.replace(/\s\uFFFD/g, " s");         // space followed by replacement char becomes space + "s"
                text = text.replace(/([A-Z])\uFFFD/g, "$1s");   // capital letter followed by replacement char becomes capital + "s"
                
                // More comprehensive cleanup
                text = text.replace(/√¢+/g, "'");           // Multiple √¢ becomes single '
                text = text.replace(/√Ç+/g, " ");           // Multiple √Ç becomes single space
                
                // Remove extra spaces around punctuation
                text = text.replace(/\s+([,.!?;:])/g, '$1');
                text = text.replace(/([,.!?;:])\s+/g, '$1 ');
                
                // Final cleanup - remove any remaining problematic characters
                text = text.replace(/[√¢‚Ç¨‚Ñ¢√¢‚Ç¨≈ì√¢‚Ç¨√¢‚Ç¨"√¢‚Ç¨¬¢]/g, function(match) {
                    switch(match) {
                        case '√¢‚Ç¨‚Ñ¢': return "'";
                        case '√¢‚Ç¨≈ì': return '"';
                        case '√¢‚Ç¨': return '"';
                        case '√¢‚Ç¨"': return '‚Äî';
                        case '√¢‚Ç¨¬¢': return '‚Ä¢';
                        default: return "'";
                    }
                });
                
                // Catch any remaining √¢ that wasn't handled
                text = text.replace(/√¢/g, "'");
                text = text.replace(/√Ç/g, " ");
                
                // Final pass for corrupted "s" character
                text = text.replace(/\uFFFD/g, "s");
                
                // Final space cleanup
                text = text.replace(/\s+/g, ' ').trim();
                
                // Aggressive character replacement for encoding issues
                text = text.replace(/‚Ç¨/g, "s");                 // euro symbol becomes "s"
                text = text.replace(/\u20AC/g, "s");            // Unicode euro symbol becomes "s"
                text = text.replace(/\u2019/g, "'s");           // Right single quotation mark becomes 's
                text = text.replace(/\u2018/g, "'s");           // Left single quotation mark becomes 's
                text = text.replace(/\u201C/g, "'s");           // Left double quotation mark becomes 's
                text = text.replace(/\u201D/g, "'s");           // Right double quotation mark becomes 's
                text = text.replace(/'/g, "'s");                // Any remaining ' becomes 's
                text = text.replace(/√¢‚Ç¨‚Ñ¢/g, "'s");              // Common encoding pattern becomes 's
                text = text.replace(/√¢‚Ç¨≈ì/g, "'s");              // Common encoding pattern becomes 's
                text = text.replace(/√¢‚Ç¨/g, "'s");               // Common encoding pattern becomes 's
                text = text.replace(/s‚Ç¨/g, "s");                // s followed by euro becomes just s
                text = text.replace(/‚Ç¨/g, "");                  // Any remaining euro becomes empty
                
                // Final aggressive cleanup for any remaining problematic characters
                text = text.replace(/s[^\w\s]/g, "s");          // s followed by any non-word/non-space character becomes just s
                const beforeUrlCleanup2 = text;
                text = text.replace(/[^\w\s.,!?;:'"()\/\-:]/g, "");  // Remove any remaining special characters except basic punctuation and URL characters
                
                // Debug URL processing
                if (beforeUrlCleanup2.includes('https') || beforeUrlCleanup2.includes('http')) {
                    console.log('üîó URL processing in cleanHtmlText:');
                    console.log('Before:', beforeUrlCleanup2.substring(beforeUrlCleanup2.indexOf('http'), beforeUrlCleanup2.indexOf('http') + 50));
                    console.log('After:', text.substring(text.indexOf('http'), text.indexOf('http') + 50));
                }
                
                // Remove filler text and placeholder content
                text = this.removeFillerText(text);
                
                return text;
            }
            
            lzwDecompress(compressedData) {
                // Decode base64
                const binaryString = atob(compressedData);
                const bytes = new Uint8Array(binaryString.length);
                for (let i = 0; i < binaryString.length; i++) {
                    bytes[i] = binaryString.charCodeAt(i);
                }
                
                // LZW decompression
                const dict = {};
                const data = Array.from(bytes);
                let currChar = String.fromCharCode(data[0]);
                let oldPhrase = currChar;
                const result = [currChar];
                let code = 256;
                let phrase;
                
                for (let i = 1; i < data.length; i++) {
                    const currCode = data[i];
                    if (currCode < 256) {
                        phrase = String.fromCharCode(currCode);
                    } else {
                        phrase = dict[currCode] ? dict[currCode] : (oldPhrase + currChar);
                    }
                    result.push(phrase);
                    currChar = phrase.charAt(0);
                    dict[code] = oldPhrase + currChar;
                    code++;
                    oldPhrase = phrase;
                }
                
                return result.join('');
            }
            
            showStatus(type, message) {
                const status = document.getElementById('status');
                const statusText = document.getElementById('statusText');
                
                status.className = `status ${type}`;
                status.style.display = 'block';
                statusText.textContent = message;
                
                const uploadArea = document.getElementById('uploadArea');
                if (type === 'processing') {
                    uploadArea.classList.add('processing');
                } else {
                    uploadArea.classList.remove('processing');
                }
            }
            
            updateProgress(percent) {
                const progressFill = document.getElementById('progressFill');
                progressFill.style.width = `${percent}%`;
            }
            
            downloadFile() {
                if (!this.extractedContent) return;
                
                const outputFormat = document.querySelector('input[name="outputFormat"]:checked').value;
                
                let content = this.extractedContent;
                let filename = `${this.filename}_extracted`;
                let mimeType = 'text/markdown';
                
                if (outputFormat === 'html') {
                    // Convert markdown to HTML
                    content = this.convertToHtml(content);
                    filename += '.html';
                    mimeType = 'text/html';
                } else {
                    filename += '.md';
                }
                
                const blob = new Blob([content], { type: mimeType });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }
            
            convertToHtml(markdownContent) {
                // Simple markdown to HTML conversion
                let html = markdownContent
                    // Headers
                    .replace(/^### (.*$)/gm, '<h3>$1</h3>')
                    .replace(/^## (.*$)/gm, '<h2>$1</h2>')
                    .replace(/^# (.*$)/gm, '<h1>$1</h1>')
                    // Bold
                    .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
                    // Italic
                    .replace(/\*(.*?)\*/g, '<em>$1</em>')
                    // Images
                    .replace(/!\[(.*?)\]\((.*?)\)/g, '<img src="$2" alt="$1" style="max-width: 100%; height: auto;">')
                    // Horizontal rules
                    .replace(/^---$/gm, '<hr>')
                    // Line breaks
                    .replace(/\n\n/g, '</p><p>')
                    .replace(/\n/g, '<br>');
                
                // Wrap in basic HTML structure
                return `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SCORM Content Extract</title>
    <style>
        body { font-family: Arial, sans-serif; max-width: 800px; margin: 0 auto; padding: 20px; line-height: 1.6; }
        h1 { color: #2c3e50; border-bottom: 2px solid #3498db; padding-bottom: 10px; }
        h2 { color: #34495e; border-bottom: 1px solid #bdc3c7; padding-bottom: 5px; }
        h3 { color: #7f8c8d; }
        img { border: 1px solid #ddd; border-radius: 4px; padding: 5px; margin: 10px 0; }
        hr { border: none; height: 1px; background-color: #bdc3c7; margin: 20px 0; }
        .emoji { font-size: 1.2em; }
    </style>
</head>
<body>
    <p>${html}</p>
</body>
</html>`;
            }
        }
        
        // Initialize the application
        document.addEventListener('DOMContentLoaded', () => {
            new ScormExtractor();
        });
    </script>
</body>
</html>
